Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_power.oepc_true-unreach-call.c
Converting
Type-checking safe037_power.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 162 127 107 87 80 75 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 
79: 
80: 81 
81: 82 
82: 83 
83: 
84: 
85: 
86: 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 180 
178: 
179: 
180: 181 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 168
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Property: main$tmp_guard0 != FALSE
Line: 175
Assertion: main 174
Line: 176
Line: 177
Line: 180
Line: 181
Line: 184
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 185
Assertion: main 184
Line: 186
Line: 148
Line: 155
Line: 166
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 68
Line: 32
Line: 44
Line: 38
Line: 62
Line: 73
Line: 21
Line: 79
Line: 26
Line: 57
Line: 53
Line: 50
Line: 56
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 75
Property: __global_lock == 1
Line: 76
Assertion: __VERIFIER_atomic_end 75
Line: 77
Line: 78
Line: 80
Property: __global_lock == 0
Line: 81
Assertion: __VERIFIER_atomic_begin 80
Line: 82
Line: 83
Line: 87
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 107
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 127
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 162
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: 6
88: 0
89: 6
90: 6
91: 6
92: 6
93: 0
94: 6
95: 6
96: 6
97: 6
98: 0
99: 6
100: 0
101: 0
102: -1
103: -1
104: -1
105: -1
106: -1
107: 6
108: 0
109: 6
110: 6
111: 6
112: 6
113: 0
114: 6
115: 6
116: 6
117: 6
118: 0
119: 6
120: 0
121: 0
122: -1
123: -1
124: -1
125: -1
126: -1
127: 6
128: 0
129: 6
130: 6
131: 6
132: 6
133: 0
134: 6
135: 6
136: 6
137: 6
138: 0
139: 6
140: 0
141: 0
142: -1
143: -1
144: -1
145: -1
146: -1
147: -1
148: 0
149: -1
150: -1
151: -1
152: -1
153: -1
154: -1
155: 0
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: 0
163: -1
164: -1
165: -1
166: -1
167: -1
168: 6
169: 6
170: 6
171: 6
172: 0
173: 6
174: 0
175: 6
176: 6
177: 6
178: -1
179: -1
180: 2
181: 6
182: -1
183: -1
184: 0
185: 0
186: 0
187: -1
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 89 to 90
Removing from 94 to 95
Removing from 109 to 110
Removing from 114 to 115
Removing from 129 to 130
Removing from 134 to 135
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 174 to 175
at line 74:  __VERIFIER_assume(__global_lock==1); 
at line 75:  __global_lock=0; 
at line 76:  return; 
at line 77:}
counter: 0
at line 79:  __VERIFIER_assume(__global_lock==0); 
at line 80:  __global_lock=1; 
at line 81:  return; 
at line 82:}
counter: 0
at line 86:  __VERIFIER_atomic_begin();
at line 87:  z = 1;
at line 88:  __VERIFIER_atomic_end();
at line 89:
at line 90:
at line 91:  __VERIFIER_atomic_begin();
at line 92:  __unbuffered_p0_EAX = x;
at line 93:  __VERIFIER_atomic_end();
at line 94:
at line 95:
at line 96:  __VERIFIER_atomic_begin();
at line 97:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 98:  __VERIFIER_atomic_end();
at line 99:  return nondet_0();
at line 100:}
counter: 0
at line 106:  __VERIFIER_atomic_begin();
at line 107:  x = 1;
at line 108:  __VERIFIER_atomic_end();
at line 109:
at line 110:
at line 111:  __VERIFIER_atomic_begin();
at line 112:  __unbuffered_p1_EAX = y;
at line 113:  __VERIFIER_atomic_end();
at line 114:
at line 115:
at line 116:  __VERIFIER_atomic_begin();
at line 117:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 118:  __VERIFIER_atomic_end();
at line 119:  return nondet_0();
at line 120:}
counter: 0
at line 126:  __VERIFIER_atomic_begin();
at line 127:  y = 1;
at line 128:  __VERIFIER_atomic_end();
at line 129:
at line 130:
at line 131:  __VERIFIER_atomic_begin();
at line 132:  __unbuffered_p2_EAX = z;
at line 133:  __VERIFIER_atomic_end();
at line 134:
at line 135:
at line 136:  __VERIFIER_atomic_begin();
at line 137:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 138:  __VERIFIER_atomic_end();
at line 139:  return nondet_0();
at line 140:}
counter: 0
at line 146:  
at line 147:}
counter: 0
at line 153:  
at line 154:}
counter: 0
at line 160:  
at line 161:}
counter: 0
at line 167:pthread_create(NULL, NULL, P0, NULL);
at line 168:pthread_create(NULL, NULL, P1, NULL);
at line 169:pthread_create(NULL, NULL, P2, NULL);
at line 170:  __VERIFIER_atomic_begin();
at line 171:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 172:  __VERIFIER_atomic_end();
at line 173:  __VERIFIER_assume(main$tmp_guard0);
at line 174:
at line 175:
at line 176:  __VERIFIER_atomic_begin();
at line 177:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 178:This likely is a bug in the tool chain. */
at line 179:
at line 180:  __VERIFIER_atomic_end();
at line 181:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 182:This likely is a bug in the tool chain. */
at line 183:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 184:  return 0;
at line 185:}
counter: 0
at line 186:
at line 74:  __VERIFIER_assume(__global_lock==1); 
at line 75:  __global_lock=0; 
at line 76:  return; 
at line 77:}
at line 78:void __VERIFIER_atomic_begin() { 
at line 79:  __VERIFIER_assume(__global_lock==0); 
at line 80:  __global_lock=1; 
at line 81:  return; 
at line 82:}
at line 83:
at line 84:void * P0(void *arg)
at line 85:{
at line 86:  __VERIFIER_atomic_begin();
at line 87:  z = 1;
at line 88:  __VERIFIER_atomic_end();
at line 89:
at line 90:
at line 91:  __VERIFIER_atomic_begin();
at line 92:  __unbuffered_p0_EAX = x;
at line 93:  __VERIFIER_atomic_end();
at line 94:
at line 95:
at line 96:  __VERIFIER_atomic_begin();
at line 97:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 98:  __VERIFIER_atomic_end();
at line 99:  return nondet_0();
at line 100:}
at line 101:
at line 102:
at line 103:
at line 104:void * P1(void *arg)
at line 105:{
at line 106:  __VERIFIER_atomic_begin();
at line 107:  x = 1;
at line 108:  __VERIFIER_atomic_end();
at line 109:
at line 110:
at line 111:  __VERIFIER_atomic_begin();
at line 112:  __unbuffered_p1_EAX = y;
at line 113:  __VERIFIER_atomic_end();
at line 114:
at line 115:
at line 116:  __VERIFIER_atomic_begin();
at line 117:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 118:  __VERIFIER_atomic_end();
at line 119:  return nondet_0();
at line 120:}
at line 121:
at line 122:
at line 123:
at line 124:void * P2(void *arg)
at line 125:{
at line 126:  __VERIFIER_atomic_begin();
at line 127:  y = 1;
at line 128:  __VERIFIER_atomic_end();
at line 129:
at line 130:
at line 131:  __VERIFIER_atomic_begin();
at line 132:  __unbuffered_p2_EAX = z;
at line 133:  __VERIFIER_atomic_end();
at line 134:
at line 135:
at line 136:  __VERIFIER_atomic_begin();
at line 137:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 138:  __VERIFIER_atomic_end();
at line 139:  return nondet_0();
at line 140:}
at line 141:
at line 142:
at line 143:
at line 144:void fence()
at line 145:{
at line 146:  
at line 147:}
at line 148:
at line 149:
at line 150:
at line 151:void isync()
at line 152:{
at line 153:  
at line 154:}
at line 155:
at line 156:
at line 157:
at line 158:void lwfence()
at line 159:{
at line 160:  
at line 161:}
at line 162:
at line 163:
at line 164:
at line 165:int main()
at line 166:{
at line 167:pthread_create(NULL, NULL, P0, NULL);
at line 168:pthread_create(NULL, NULL, P1, NULL);
at line 169:pthread_create(NULL, NULL, P2, NULL);
at line 170:  __VERIFIER_atomic_begin();
at line 171:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 172:  __VERIFIER_atomic_end();
at line 173:  __VERIFIER_assume(main$tmp_guard0);
at line 174:
at line 175:
at line 176:  __VERIFIER_atomic_begin();
at line 177:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 178:This likely is a bug in the tool chain. */
at line 179:
at line 180:  __VERIFIER_atomic_end();
at line 181:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 182:This likely is a bug in the tool chain. */
at line 183:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 184:  return 0;
at line 185:}
at line 186:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 147 148
Update CFG: 154 155
Update CFG: 161 162
0: 162 127 107 87 80 75 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 
79: 
80: 81 
81: 82 
82: 83 
83: 
84: 
85: 
86: 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 148 
148: 
149: 
150: 
151: 
152: 
153: 
154: 155 
155: 
156: 
157: 
158: 
159: 
160: 
161: 162 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 180 
178: 
179: 
180: 181 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 162 128 108 88 80 75 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 
79: 
80: 81 
81: 82 
82: 83 
83: 
84: 
85: 
86: 
87: 
88: 93 
89: 
90: 
91: 
92: 
93: 98 
94: 
95: 
96: 
97: 
98: 100 
99: 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 113 
109: 
110: 
111: 
112: 
113: 118 
114: 
115: 
116: 
117: 
118: 120 
119: 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 133 
129: 
130: 
131: 
132: 
133: 138 
134: 
135: 
136: 
137: 
138: 140 
139: 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 172 
171: 
172: 174 
173: 
174: 177 
175: 
176: 
177: 181 
178: 
179: 
180: 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.183s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_power.opt_true-unreach-call.c
Converting
Type-checking safe037_power.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 164 129 109 89 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 179 
179: 182 
180: 
181: 
182: 183 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
197: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Line: 175
Line: 176
Property: main$tmp_guard0 != FALSE
Line: 177
Assertion: main 176
Line: 178
Line: 179
Line: 182
Line: 183
Line: 186
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 187
Assertion: main 186
Line: 188
Line: 150
Line: 157
Line: 168
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 70
Line: 34
Line: 46
Line: 40
Line: 64
Line: 75
Line: 21
Line: 79
Line: 28
Line: 57
Line: 55
Line: 52
Line: 58
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 77
Property: __global_lock == 1
Line: 78
Assertion: __VERIFIER_atomic_end 77
Line: 79
Line: 80
Line: 82
Property: __global_lock == 0
Line: 83
Assertion: __VERIFIER_atomic_begin 82
Line: 84
Line: 85
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 122
Line: 123
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Line: 143
Line: 164
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: -1
88: -1
89: 6
90: 0
91: 6
92: 6
93: 6
94: 6
95: 0
96: 6
97: 6
98: 6
99: 6
100: 0
101: 6
102: 0
103: 0
104: -1
105: -1
106: -1
107: -1
108: -1
109: 6
110: 0
111: 6
112: 6
113: 6
114: 6
115: 0
116: 6
117: 6
118: 6
119: 6
120: 0
121: 6
122: 0
123: 0
124: -1
125: -1
126: -1
127: -1
128: -1
129: 6
130: 0
131: 6
132: 6
133: 6
134: 6
135: 0
136: 6
137: 6
138: 6
139: 6
140: 0
141: 6
142: 0
143: 0
144: -1
145: -1
146: -1
147: -1
148: -1
149: -1
150: 0
151: -1
152: -1
153: -1
154: -1
155: -1
156: -1
157: 0
158: -1
159: -1
160: -1
161: -1
162: -1
163: -1
164: 0
165: -1
166: -1
167: -1
168: -1
169: -1
170: 6
171: 6
172: 6
173: 6
174: 0
175: 6
176: 0
177: 6
178: 6
179: 6
180: -1
181: -1
182: 2
183: 6
184: -1
185: -1
186: 0
187: 0
188: 0
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1
196: -1
197: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 91 to 92
Removing from 96 to 97
Removing from 111 to 112
Removing from 116 to 117
Removing from 131 to 132
Removing from 136 to 137
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 176 to 177
at line 76:  __VERIFIER_assume(__global_lock==1); 
at line 77:  __global_lock=0; 
at line 78:  return; 
at line 79:}
counter: 0
at line 81:  __VERIFIER_assume(__global_lock==0); 
at line 82:  __global_lock=1; 
at line 83:  return; 
at line 84:}
counter: 0
at line 88:  __VERIFIER_atomic_begin();
at line 89:  z = 1;
at line 90:  __VERIFIER_atomic_end();
at line 91:
at line 92:
at line 93:  __VERIFIER_atomic_begin();
at line 94:  __unbuffered_p0_EAX = x;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 100:  __VERIFIER_atomic_end();
at line 101:  return nondet_0();
at line 102:}
counter: 0
at line 108:  __VERIFIER_atomic_begin();
at line 109:  x = 1;
at line 110:  __VERIFIER_atomic_end();
at line 111:
at line 112:
at line 113:  __VERIFIER_atomic_begin();
at line 114:  __unbuffered_p1_EAX = y;
at line 115:  __VERIFIER_atomic_end();
at line 116:
at line 117:
at line 118:  __VERIFIER_atomic_begin();
at line 119:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 120:  __VERIFIER_atomic_end();
at line 121:  return nondet_0();
at line 122:}
counter: 0
at line 128:  __VERIFIER_atomic_begin();
at line 129:  y = 1;
at line 130:  __VERIFIER_atomic_end();
at line 131:
at line 132:
at line 133:  __VERIFIER_atomic_begin();
at line 134:  __unbuffered_p2_EAX = z;
at line 135:  __VERIFIER_atomic_end();
at line 136:
at line 137:
at line 138:  __VERIFIER_atomic_begin();
at line 139:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 140:  __VERIFIER_atomic_end();
at line 141:  return nondet_0();
at line 142:}
counter: 0
at line 148:  
at line 149:}
counter: 0
at line 155:  
at line 156:}
counter: 0
at line 162:  
at line 163:}
counter: 0
at line 169:pthread_create(NULL, NULL, P0, NULL);
at line 170:pthread_create(NULL, NULL, P1, NULL);
at line 171:pthread_create(NULL, NULL, P2, NULL);
at line 172:  __VERIFIER_atomic_begin();
at line 173:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 174:  __VERIFIER_atomic_end();
at line 175:  __VERIFIER_assume(main$tmp_guard0);
at line 176:
at line 177:
at line 178:  __VERIFIER_atomic_begin();
at line 179:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 180:This likely is a bug in the tool chain. */
at line 181:
at line 182:  __VERIFIER_atomic_end();
at line 183:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 184:This likely is a bug in the tool chain. */
at line 185:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 186:  return 0;
at line 187:}
counter: 0
at line 188:
at line 76:  __VERIFIER_assume(__global_lock==1); 
at line 77:  __global_lock=0; 
at line 78:  return; 
at line 79:}
at line 80:void __VERIFIER_atomic_begin() { 
at line 81:  __VERIFIER_assume(__global_lock==0); 
at line 82:  __global_lock=1; 
at line 83:  return; 
at line 84:}
at line 85:
at line 86:void * P0(void *arg)
at line 87:{
at line 88:  __VERIFIER_atomic_begin();
at line 89:  z = 1;
at line 90:  __VERIFIER_atomic_end();
at line 91:
at line 92:
at line 93:  __VERIFIER_atomic_begin();
at line 94:  __unbuffered_p0_EAX = x;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 100:  __VERIFIER_atomic_end();
at line 101:  return nondet_0();
at line 102:}
at line 103:
at line 104:
at line 105:
at line 106:void * P1(void *arg)
at line 107:{
at line 108:  __VERIFIER_atomic_begin();
at line 109:  x = 1;
at line 110:  __VERIFIER_atomic_end();
at line 111:
at line 112:
at line 113:  __VERIFIER_atomic_begin();
at line 114:  __unbuffered_p1_EAX = y;
at line 115:  __VERIFIER_atomic_end();
at line 116:
at line 117:
at line 118:  __VERIFIER_atomic_begin();
at line 119:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 120:  __VERIFIER_atomic_end();
at line 121:  return nondet_0();
at line 122:}
at line 123:
at line 124:
at line 125:
at line 126:void * P2(void *arg)
at line 127:{
at line 128:  __VERIFIER_atomic_begin();
at line 129:  y = 1;
at line 130:  __VERIFIER_atomic_end();
at line 131:
at line 132:
at line 133:  __VERIFIER_atomic_begin();
at line 134:  __unbuffered_p2_EAX = z;
at line 135:  __VERIFIER_atomic_end();
at line 136:
at line 137:
at line 138:  __VERIFIER_atomic_begin();
at line 139:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 140:  __VERIFIER_atomic_end();
at line 141:  return nondet_0();
at line 142:}
at line 143:
at line 144:
at line 145:
at line 146:void fence()
at line 147:{
at line 148:  
at line 149:}
at line 150:
at line 151:
at line 152:
at line 153:void isync()
at line 154:{
at line 155:  
at line 156:}
at line 157:
at line 158:
at line 159:
at line 160:void lwfence()
at line 161:{
at line 162:  
at line 163:}
at line 164:
at line 165:
at line 166:
at line 167:int main()
at line 168:{
at line 169:pthread_create(NULL, NULL, P0, NULL);
at line 170:pthread_create(NULL, NULL, P1, NULL);
at line 171:pthread_create(NULL, NULL, P2, NULL);
at line 172:  __VERIFIER_atomic_begin();
at line 173:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 174:  __VERIFIER_atomic_end();
at line 175:  __VERIFIER_assume(main$tmp_guard0);
at line 176:
at line 177:
at line 178:  __VERIFIER_atomic_begin();
at line 179:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 180:This likely is a bug in the tool chain. */
at line 181:
at line 182:  __VERIFIER_atomic_end();
at line 183:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 184:This likely is a bug in the tool chain. */
at line 185:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 186:  return 0;
at line 187:}
at line 188:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 149 150
Update CFG: 156 157
Update CFG: 163 164
0: 164 129 109 89 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 150 
150: 
151: 
152: 
153: 
154: 
155: 
156: 157 
157: 
158: 
159: 
160: 
161: 
162: 
163: 164 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 179 
179: 182 
180: 
181: 
182: 183 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 164 130 110 90 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 
90: 95 
91: 
92: 
93: 
94: 
95: 100 
96: 
97: 
98: 
99: 
100: 102 
101: 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 115 
111: 
112: 
113: 
114: 
115: 120 
116: 
117: 
118: 
119: 
120: 122 
121: 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 135 
131: 
132: 
133: 
134: 
135: 140 
136: 
137: 
138: 
139: 
140: 142 
141: 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 174 
173: 
174: 176 
175: 
176: 179 
177: 
178: 
179: 183 
180: 
181: 
182: 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
197: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.181s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_pso.oepc_true-unreach-call.c
Converting
Type-checking safe037_pso.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Line: 175
Property: main$tmp_guard0 != FALSE
Line: 176
Assertion: main 175
Line: 177
Line: 178
Line: 181
Line: 182
Line: 185
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 186
Assertion: main 185
Line: 187
Line: 149
Line: 156
Line: 167
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 69
Line: 33
Line: 45
Line: 39
Line: 63
Line: 74
Line: 21
Line: 79
Line: 27
Line: 57
Line: 54
Line: 51
Line: 57
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 76
Property: __global_lock == 1
Line: 77
Assertion: __VERIFIER_atomic_end 76
Line: 78
Line: 79
Line: 81
Property: __global_lock == 0
Line: 82
Assertion: __VERIFIER_atomic_begin 81
Line: 83
Line: 84
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 122
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Line: 163
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: -1
88: 6
89: 0
90: 6
91: 6
92: 6
93: 6
94: 0
95: 6
96: 6
97: 6
98: 6
99: 0
100: 6
101: 0
102: 0
103: -1
104: -1
105: -1
106: -1
107: -1
108: 6
109: 0
110: 6
111: 6
112: 6
113: 6
114: 0
115: 6
116: 6
117: 6
118: 6
119: 0
120: 6
121: 0
122: 0
123: -1
124: -1
125: -1
126: -1
127: -1
128: 6
129: 0
130: 6
131: 6
132: 6
133: 6
134: 0
135: 6
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 0
143: -1
144: -1
145: -1
146: -1
147: -1
148: -1
149: 0
150: -1
151: -1
152: -1
153: -1
154: -1
155: -1
156: 0
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: 0
164: -1
165: -1
166: -1
167: -1
168: -1
169: 6
170: 6
171: 6
172: 6
173: 0
174: 6
175: 0
176: 6
177: 6
178: 6
179: -1
180: -1
181: 2
182: 6
183: -1
184: -1
185: 0
186: 0
187: 0
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1
196: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 90 to 91
Removing from 95 to 96
Removing from 110 to 111
Removing from 115 to 116
Removing from 130 to 131
Removing from 135 to 136
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 175 to 176
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
counter: 0
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
counter: 0
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
counter: 0
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
counter: 0
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
counter: 0
at line 147:  
at line 148:}
counter: 0
at line 154:  
at line 155:}
counter: 0
at line 161:  
at line 162:}
counter: 0
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
counter: 0
at line 187:
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
at line 79:void __VERIFIER_atomic_begin() { 
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
at line 84:
at line 85:void * P0(void *arg)
at line 86:{
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
at line 102:
at line 103:
at line 104:
at line 105:void * P1(void *arg)
at line 106:{
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
at line 122:
at line 123:
at line 124:
at line 125:void * P2(void *arg)
at line 126:{
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
at line 142:
at line 143:
at line 144:
at line 145:void fence()
at line 146:{
at line 147:  
at line 148:}
at line 149:
at line 150:
at line 151:
at line 152:void isync()
at line 153:{
at line 154:  
at line 155:}
at line 156:
at line 157:
at line 158:
at line 159:void lwfence()
at line 160:{
at line 161:  
at line 162:}
at line 163:
at line 164:
at line 165:
at line 166:int main()
at line 167:{
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
at line 187:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 148 149
Update CFG: 155 156
Update CFG: 162 163
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 149 
149: 
150: 
151: 
152: 
153: 
154: 
155: 156 
156: 
157: 
158: 
159: 
160: 
161: 
162: 163 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 129 109 89 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 
89: 94 
90: 
91: 
92: 
93: 
94: 99 
95: 
96: 
97: 
98: 
99: 101 
100: 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 114 
110: 
111: 
112: 
113: 
114: 119 
115: 
116: 
117: 
118: 
119: 121 
120: 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 134 
130: 
131: 
132: 
133: 
134: 139 
135: 
136: 
137: 
138: 
139: 141 
140: 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 173 
172: 
173: 175 
174: 
175: 178 
176: 
177: 
178: 182 
179: 
180: 
181: 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.178s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_pso.opt_true-unreach-call.c
Converting
Type-checking safe037_pso.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Line: 175
Property: main$tmp_guard0 != FALSE
Line: 176
Assertion: main 175
Line: 177
Line: 178
Line: 181
Line: 182
Line: 185
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 186
Assertion: main 185
Line: 187
Line: 149
Line: 156
Line: 167
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 69
Line: 33
Line: 45
Line: 39
Line: 63
Line: 74
Line: 21
Line: 79
Line: 27
Line: 57
Line: 54
Line: 51
Line: 57
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 76
Property: __global_lock == 1
Line: 77
Assertion: __VERIFIER_atomic_end 76
Line: 78
Line: 79
Line: 81
Property: __global_lock == 0
Line: 82
Assertion: __VERIFIER_atomic_begin 81
Line: 83
Line: 84
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 122
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Line: 163
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: -1
88: 6
89: 0
90: 6
91: 6
92: 6
93: 6
94: 0
95: 6
96: 6
97: 6
98: 6
99: 0
100: 6
101: 0
102: 0
103: -1
104: -1
105: -1
106: -1
107: -1
108: 6
109: 0
110: 6
111: 6
112: 6
113: 6
114: 0
115: 6
116: 6
117: 6
118: 6
119: 0
120: 6
121: 0
122: 0
123: -1
124: -1
125: -1
126: -1
127: -1
128: 6
129: 0
130: 6
131: 6
132: 6
133: 6
134: 0
135: 6
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 0
143: -1
144: -1
145: -1
146: -1
147: -1
148: -1
149: 0
150: -1
151: -1
152: -1
153: -1
154: -1
155: -1
156: 0
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: 0
164: -1
165: -1
166: -1
167: -1
168: -1
169: 6
170: 6
171: 6
172: 6
173: 0
174: 6
175: 0
176: 6
177: 6
178: 6
179: -1
180: -1
181: 2
182: 6
183: -1
184: -1
185: 0
186: 0
187: 0
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1
196: -1

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 90 to 91
Removing from 95 to 96
Removing from 110 to 111
Removing from 115 to 116
Removing from 130 to 131
Removing from 135 to 136
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 175 to 176
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
counter: 0
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
counter: 0
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
counter: 0
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
counter: 0
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
counter: 0
at line 147:  
at line 148:}
counter: 0
at line 154:  
at line 155:}
counter: 0
at line 161:  
at line 162:}
counter: 0
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
counter: 0
at line 187:
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
at line 79:void __VERIFIER_atomic_begin() { 
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
at line 84:
at line 85:void * P0(void *arg)
at line 86:{
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
at line 102:
at line 103:
at line 104:
at line 105:void * P1(void *arg)
at line 106:{
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
at line 122:
at line 123:
at line 124:
at line 125:void * P2(void *arg)
at line 126:{
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
at line 142:
at line 143:
at line 144:
at line 145:void fence()
at line 146:{
at line 147:  
at line 148:}
at line 149:
at line 150:
at line 151:
at line 152:void isync()
at line 153:{
at line 154:  
at line 155:}
at line 156:
at line 157:
at line 158:
at line 159:void lwfence()
at line 160:{
at line 161:  
at line 162:}
at line 163:
at line 164:
at line 165:
at line 166:int main()
at line 167:{
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
at line 187:

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 148 149
Update CFG: 155 156
Update CFG: 162 163
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 149 
149: 
150: 
151: 
152: 
153: 
154: 
155: 156 
156: 
157: 
158: 
159: 
160: 
161: 
162: 163 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 129 109 89 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 
89: 94 
90: 
91: 
92: 
93: 
94: 99 
95: 
96: 
97: 
98: 
99: 101 
100: 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 114 
110: 
111: 
112: 
113: 
114: 119 
115: 
116: 
117: 
118: 
119: 121 
120: 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 134 
130: 
131: 
132: 
133: 
134: 139 
135: 
136: 
137: 
138: 
139: 141 
140: 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 173 
172: 
173: 175 
174: 
175: 178 
176: 
177: 
178: 182 
179: 
180: 
181: 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.189s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_rmo.oepc_true-unreach-call.c
Converting
Type-checking safe037_rmo.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 164 129 109 89 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 179 
179: 182 
180: 
181: 
182: 183 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
197: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Line: 175
Line: 176
Property: main$tmp_guard0 != FALSE
Line: 177
Assertion: main 176
Line: 178
Line: 179
Line: 182
Line: 183
Line: 186
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 187
Assertion: main 186
Line: 188
Line: 150
Line: 157
Line: 168
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 70
Line: 34
Line: 46
Line: 40
Line: 64
Line: 75
Line: 21
Line: 79
Line: 28
Line: 57
Line: 55
Line: 52
Line: 58
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 77
Property: __global_lock == 1
Line: 78
Assertion: __VERIFIER_atomic_end 77
Line: 79
Line: 80
Line: 82
Property: __global_lock == 0
Line: 83
Assertion: __VERIFIER_atomic_begin 82
Line: 84
Line: 85
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 122
Line: 123
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Line: 143
Line: 164
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: -1
88: -1
89: 6
90: 0
91: 6
92: 6
93: 6
94: 6
95: 0
96: 6
97: 6
98: 6
99: 6
100: 0
101: 6
102: 0
103: 0
104: -1
105: -1
106: -1
107: -1
108: -1
109: 6
110: 0
111: 6
112: 6
113: 6
114: 6
115: 0
116: 6
117: 6
118: 6
119: 6
120: 0
121: 6
122: 0
123: 0
124: -1
125: -1
126: -1
127: -1
128: -1
129: 6
130: 0
131: 6
132: 6
133: 6
134: 6
135: 0
136: 6
137: 6
138: 6
139: 6
140: 0
141: 6
142: 0
143: 0
144: -1
145: -1
146: -1
147: -1
148: -1
149: -1
150: 0
151: -1
152: -1
153: -1
154: -1
155: -1
156: -1
157: 0
158: -1
159: -1
160: -1
161: -1
162: -1
163: -1
164: 0
165: -1
166: -1
167: -1
168: -1
169: -1
170: 6
171: 6
172: 6
173: 6
174: 0
175: 6
176: 0
177: 6
178: 6
179: 6
180: -1
181: -1
182: 2
183: 6
184: -1
185: -1
186: 0
187: 0
188: 0
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1
196: -1
197: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 91 to 92
Removing from 96 to 97
Removing from 111 to 112
Removing from 116 to 117
Removing from 131 to 132
Removing from 136 to 137
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 176 to 177
at line 76:  __VERIFIER_assume(__global_lock==1); 
at line 77:  __global_lock=0; 
at line 78:  return; 
at line 79:}
counter: 0
at line 81:  __VERIFIER_assume(__global_lock==0); 
at line 82:  __global_lock=1; 
at line 83:  return; 
at line 84:}
counter: 0
at line 88:  __VERIFIER_atomic_begin();
at line 89:  z = 1;
at line 90:  __VERIFIER_atomic_end();
at line 91:
at line 92:
at line 93:  __VERIFIER_atomic_begin();
at line 94:  __unbuffered_p0_EAX = x;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 100:  __VERIFIER_atomic_end();
at line 101:  return nondet_0();
at line 102:}
counter: 0
at line 108:  __VERIFIER_atomic_begin();
at line 109:  x = 1;
at line 110:  __VERIFIER_atomic_end();
at line 111:
at line 112:
at line 113:  __VERIFIER_atomic_begin();
at line 114:  __unbuffered_p1_EAX = y;
at line 115:  __VERIFIER_atomic_end();
at line 116:
at line 117:
at line 118:  __VERIFIER_atomic_begin();
at line 119:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 120:  __VERIFIER_atomic_end();
at line 121:  return nondet_0();
at line 122:}
counter: 0
at line 128:  __VERIFIER_atomic_begin();
at line 129:  y = 1;
at line 130:  __VERIFIER_atomic_end();
at line 131:
at line 132:
at line 133:  __VERIFIER_atomic_begin();
at line 134:  __unbuffered_p2_EAX = z;
at line 135:  __VERIFIER_atomic_end();
at line 136:
at line 137:
at line 138:  __VERIFIER_atomic_begin();
at line 139:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 140:  __VERIFIER_atomic_end();
at line 141:  return nondet_0();
at line 142:}
counter: 0
at line 148:  
at line 149:}
counter: 0
at line 155:  
at line 156:}
counter: 0
at line 162:  
at line 163:}
counter: 0
at line 169:pthread_create(NULL, NULL, P0, NULL);
at line 170:pthread_create(NULL, NULL, P1, NULL);
at line 171:pthread_create(NULL, NULL, P2, NULL);
at line 172:  __VERIFIER_atomic_begin();
at line 173:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 174:  __VERIFIER_atomic_end();
at line 175:  __VERIFIER_assume(main$tmp_guard0);
at line 176:
at line 177:
at line 178:  __VERIFIER_atomic_begin();
at line 179:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 180:This likely is a bug in the tool chain. */
at line 181:
at line 182:  __VERIFIER_atomic_end();
at line 183:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 184:This likely is a bug in the tool chain. */
at line 185:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 186:  return 0;
at line 187:}
counter: 0
at line 188:
at line 76:  __VERIFIER_assume(__global_lock==1); 
at line 77:  __global_lock=0; 
at line 78:  return; 
at line 79:}
at line 80:void __VERIFIER_atomic_begin() { 
at line 81:  __VERIFIER_assume(__global_lock==0); 
at line 82:  __global_lock=1; 
at line 83:  return; 
at line 84:}
at line 85:
at line 86:void * P0(void *arg)
at line 87:{
at line 88:  __VERIFIER_atomic_begin();
at line 89:  z = 1;
at line 90:  __VERIFIER_atomic_end();
at line 91:
at line 92:
at line 93:  __VERIFIER_atomic_begin();
at line 94:  __unbuffered_p0_EAX = x;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 100:  __VERIFIER_atomic_end();
at line 101:  return nondet_0();
at line 102:}
at line 103:
at line 104:
at line 105:
at line 106:void * P1(void *arg)
at line 107:{
at line 108:  __VERIFIER_atomic_begin();
at line 109:  x = 1;
at line 110:  __VERIFIER_atomic_end();
at line 111:
at line 112:
at line 113:  __VERIFIER_atomic_begin();
at line 114:  __unbuffered_p1_EAX = y;
at line 115:  __VERIFIER_atomic_end();
at line 116:
at line 117:
at line 118:  __VERIFIER_atomic_begin();
at line 119:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 120:  __VERIFIER_atomic_end();
at line 121:  return nondet_0();
at line 122:}
at line 123:
at line 124:
at line 125:
at line 126:void * P2(void *arg)
at line 127:{
at line 128:  __VERIFIER_atomic_begin();
at line 129:  y = 1;
at line 130:  __VERIFIER_atomic_end();
at line 131:
at line 132:
at line 133:  __VERIFIER_atomic_begin();
at line 134:  __unbuffered_p2_EAX = z;
at line 135:  __VERIFIER_atomic_end();
at line 136:
at line 137:
at line 138:  __VERIFIER_atomic_begin();
at line 139:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 140:  __VERIFIER_atomic_end();
at line 141:  return nondet_0();
at line 142:}
at line 143:
at line 144:
at line 145:
at line 146:void fence()
at line 147:{
at line 148:  
at line 149:}
at line 150:
at line 151:
at line 152:
at line 153:void isync()
at line 154:{
at line 155:  
at line 156:}
at line 157:
at line 158:
at line 159:
at line 160:void lwfence()
at line 161:{
at line 162:  
at line 163:}
at line 164:
at line 165:
at line 166:
at line 167:int main()
at line 168:{
at line 169:pthread_create(NULL, NULL, P0, NULL);
at line 170:pthread_create(NULL, NULL, P1, NULL);
at line 171:pthread_create(NULL, NULL, P2, NULL);
at line 172:  __VERIFIER_atomic_begin();
at line 173:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 174:  __VERIFIER_atomic_end();
at line 175:  __VERIFIER_assume(main$tmp_guard0);
at line 176:
at line 177:
at line 178:  __VERIFIER_atomic_begin();
at line 179:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 180:This likely is a bug in the tool chain. */
at line 181:
at line 182:  __VERIFIER_atomic_end();
at line 183:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 184:This likely is a bug in the tool chain. */
at line 185:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 186:  return 0;
at line 187:}
at line 188:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif





int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 149 150
Update CFG: 156 157
Update CFG: 163 164
0: 164 129 109 89 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 150 
150: 
151: 
152: 
153: 
154: 
155: 
156: 157 
157: 
158: 
159: 
160: 
161: 
162: 
163: 164 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 179 
179: 182 
180: 
181: 
182: 183 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
Total line: 188
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 164 130 110 90 82 77 157 150 170 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 
77: 78 
78: 79 
79: 80 
80: 
81: 
82: 83 
83: 84 
84: 85 
85: 
86: 
87: 
88: 
89: 
90: 95 
91: 
92: 
93: 
94: 
95: 100 
96: 
97: 
98: 
99: 
100: 102 
101: 
102: 103 
103: 
104: 
105: 
106: 
107: 
108: 
109: 
110: 115 
111: 
112: 
113: 
114: 
115: 120 
116: 
117: 
118: 
119: 
120: 122 
121: 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 135 
131: 
132: 
133: 
134: 
135: 140 
136: 
137: 
138: 
139: 
140: 142 
141: 
142: 143 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 
170: 171 
171: 172 
172: 174 
173: 
174: 176 
175: 
176: 179 
177: 
178: 
179: 183 
180: 
181: 
182: 
183: 186 
184: 
185: 
186: 187 
187: 188 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
197: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.199s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_rmo.opt_true-unreach-call.c
Converting
Type-checking safe037_rmo.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 161 126 106 86 79 74 154 147 167 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 
78: 
79: 80 
80: 81 
81: 82 
82: 
83: 
84: 
85: 
86: 87 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 
101: 
102: 
103: 
104: 
105: 
106: 107 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 
121: 
122: 
123: 
124: 
125: 
126: 127 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 168 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 179 
177: 
178: 
179: 180 
180: 183 
181: 
182: 
183: 184 
184: 185 
185: 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 167
Line: 168
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Property: main$tmp_guard0 != FALSE
Line: 174
Assertion: main 173
Line: 175
Line: 176
Line: 179
Line: 180
Line: 183
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 184
Assertion: main 183
Line: 185
Line: 147
Line: 154
Line: 165
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 67
Line: 31
Line: 43
Line: 37
Line: 61
Line: 72
Line: 21
Line: 79
Line: 25
Line: 57
Line: 52
Line: 49
Line: 55
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 74
Property: __global_lock == 1
Line: 75
Assertion: __VERIFIER_atomic_end 74
Line: 76
Line: 77
Line: 79
Property: __global_lock == 0
Line: 80
Assertion: __VERIFIER_atomic_begin 79
Line: 81
Line: 82
Line: 86
Line: 87
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 106
Line: 107
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 126
Line: 127
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 161
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: 6
87: 0
88: 6
89: 6
90: 6
91: 6
92: 0
93: 6
94: 6
95: 6
96: 6
97: 0
98: 6
99: 0
100: 0
101: -1
102: -1
103: -1
104: -1
105: -1
106: 6
107: 0
108: 6
109: 6
110: 6
111: 6
112: 0
113: 6
114: 6
115: 6
116: 6
117: 0
118: 6
119: 0
120: 0
121: -1
122: -1
123: -1
124: -1
125: -1
126: 6
127: 0
128: 6
129: 6
130: 6
131: 6
132: 0
133: 6
134: 6
135: 6
136: 6
137: 0
138: 6
139: 0
140: 0
141: -1
142: -1
143: -1
144: -1
145: -1
146: -1
147: 0
148: -1
149: -1
150: -1
151: -1
152: -1
153: -1
154: 0
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: 0
162: -1
163: -1
164: -1
165: -1
166: -1
167: 6
168: 6
169: 6
170: 6
171: 0
172: 6
173: 0
174: 6
175: 6
176: 6
177: -1
178: -1
179: 2
180: 6
181: -1
182: -1
183: 0
184: 0
185: 0
186: -1
187: -1
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif


int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 88 to 89
Removing from 93 to 94
Removing from 108 to 109
Removing from 113 to 114
Removing from 128 to 129
Removing from 133 to 134
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 173 to 174
at line 73:  __VERIFIER_assume(__global_lock==1); 
at line 74:  __global_lock=0; 
at line 75:  return; 
at line 76:}
counter: 0
at line 78:  __VERIFIER_assume(__global_lock==0); 
at line 79:  __global_lock=1; 
at line 80:  return; 
at line 81:}
counter: 0
at line 85:  __VERIFIER_atomic_begin();
at line 86:  z = 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:
at line 89:
at line 90:  __VERIFIER_atomic_begin();
at line 91:  __unbuffered_p0_EAX = x;
at line 92:  __VERIFIER_atomic_end();
at line 93:
at line 94:
at line 95:  __VERIFIER_atomic_begin();
at line 96:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:  return nondet_0();
at line 99:}
counter: 0
at line 105:  __VERIFIER_atomic_begin();
at line 106:  x = 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:
at line 109:
at line 110:  __VERIFIER_atomic_begin();
at line 111:  __unbuffered_p1_EAX = y;
at line 112:  __VERIFIER_atomic_end();
at line 113:
at line 114:
at line 115:  __VERIFIER_atomic_begin();
at line 116:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 117:  __VERIFIER_atomic_end();
at line 118:  return nondet_0();
at line 119:}
counter: 0
at line 125:  __VERIFIER_atomic_begin();
at line 126:  y = 1;
at line 127:  __VERIFIER_atomic_end();
at line 128:
at line 129:
at line 130:  __VERIFIER_atomic_begin();
at line 131:  __unbuffered_p2_EAX = z;
at line 132:  __VERIFIER_atomic_end();
at line 133:
at line 134:
at line 135:  __VERIFIER_atomic_begin();
at line 136:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 137:  __VERIFIER_atomic_end();
at line 138:  return nondet_0();
at line 139:}
counter: 0
at line 145:  
at line 146:}
counter: 0
at line 152:  
at line 153:}
counter: 0
at line 159:  
at line 160:}
counter: 0
at line 166:pthread_create(NULL, NULL, P0, NULL);
at line 167:pthread_create(NULL, NULL, P1, NULL);
at line 168:pthread_create(NULL, NULL, P2, NULL);
at line 169:  __VERIFIER_atomic_begin();
at line 170:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 171:  __VERIFIER_atomic_end();
at line 172:  __VERIFIER_assume(main$tmp_guard0);
at line 173:
at line 174:
at line 175:  __VERIFIER_atomic_begin();
at line 176:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 177:This likely is a bug in the tool chain. */
at line 178:
at line 179:  __VERIFIER_atomic_end();
at line 180:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 181:This likely is a bug in the tool chain. */
at line 182:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 183:  return 0;
at line 184:}
counter: 0
at line 185:
at line 73:  __VERIFIER_assume(__global_lock==1); 
at line 74:  __global_lock=0; 
at line 75:  return; 
at line 76:}
at line 77:void __VERIFIER_atomic_begin() { 
at line 78:  __VERIFIER_assume(__global_lock==0); 
at line 79:  __global_lock=1; 
at line 80:  return; 
at line 81:}
at line 82:
at line 83:void * P0(void *arg)
at line 84:{
at line 85:  __VERIFIER_atomic_begin();
at line 86:  z = 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:
at line 89:
at line 90:  __VERIFIER_atomic_begin();
at line 91:  __unbuffered_p0_EAX = x;
at line 92:  __VERIFIER_atomic_end();
at line 93:
at line 94:
at line 95:  __VERIFIER_atomic_begin();
at line 96:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:  return nondet_0();
at line 99:}
at line 100:
at line 101:
at line 102:
at line 103:void * P1(void *arg)
at line 104:{
at line 105:  __VERIFIER_atomic_begin();
at line 106:  x = 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:
at line 109:
at line 110:  __VERIFIER_atomic_begin();
at line 111:  __unbuffered_p1_EAX = y;
at line 112:  __VERIFIER_atomic_end();
at line 113:
at line 114:
at line 115:  __VERIFIER_atomic_begin();
at line 116:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 117:  __VERIFIER_atomic_end();
at line 118:  return nondet_0();
at line 119:}
at line 120:
at line 121:
at line 122:
at line 123:void * P2(void *arg)
at line 124:{
at line 125:  __VERIFIER_atomic_begin();
at line 126:  y = 1;
at line 127:  __VERIFIER_atomic_end();
at line 128:
at line 129:
at line 130:  __VERIFIER_atomic_begin();
at line 131:  __unbuffered_p2_EAX = z;
at line 132:  __VERIFIER_atomic_end();
at line 133:
at line 134:
at line 135:  __VERIFIER_atomic_begin();
at line 136:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 137:  __VERIFIER_atomic_end();
at line 138:  return nondet_0();
at line 139:}
at line 140:
at line 141:
at line 142:
at line 143:void fence()
at line 144:{
at line 145:  
at line 146:}
at line 147:
at line 148:
at line 149:
at line 150:void isync()
at line 151:{
at line 152:  
at line 153:}
at line 154:
at line 155:
at line 156:
at line 157:void lwfence()
at line 158:{
at line 159:  
at line 160:}
at line 161:
at line 162:
at line 163:
at line 164:int main()
at line 165:{
at line 166:pthread_create(NULL, NULL, P0, NULL);
at line 167:pthread_create(NULL, NULL, P1, NULL);
at line 168:pthread_create(NULL, NULL, P2, NULL);
at line 169:  __VERIFIER_atomic_begin();
at line 170:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 171:  __VERIFIER_atomic_end();
at line 172:  __VERIFIER_assume(main$tmp_guard0);
at line 173:
at line 174:
at line 175:  __VERIFIER_atomic_begin();
at line 176:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 177:This likely is a bug in the tool chain. */
at line 178:
at line 179:  __VERIFIER_atomic_end();
at line 180:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 181:This likely is a bug in the tool chain. */
at line 182:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 183:  return 0;
at line 184:}
at line 185:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif


int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 146 147
Update CFG: 153 154
Update CFG: 160 161
0: 161 126 106 86 79 74 154 147 167 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 
78: 
79: 80 
80: 81 
81: 82 
82: 
83: 
84: 
85: 
86: 87 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 
101: 
102: 
103: 
104: 
105: 
106: 107 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 
121: 
122: 
123: 
124: 
125: 
126: 127 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 
141: 
142: 
143: 
144: 
145: 
146: 147 
147: 
148: 
149: 
150: 
151: 
152: 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 161 
161: 
162: 
163: 
164: 
165: 
166: 
167: 168 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 179 
177: 
178: 
179: 180 
180: 183 
181: 
182: 
183: 184 
184: 185 
185: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
Total line: 185
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 161 127 107 87 79 74 154 147 167 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 
78: 
79: 80 
80: 81 
81: 82 
82: 
83: 
84: 
85: 
86: 
87: 92 
88: 
89: 
90: 
91: 
92: 97 
93: 
94: 
95: 
96: 
97: 99 
98: 
99: 100 
100: 
101: 
102: 
103: 
104: 
105: 
106: 
107: 112 
108: 
109: 
110: 
111: 
112: 117 
113: 
114: 
115: 
116: 
117: 119 
118: 
119: 120 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 132 
128: 
129: 
130: 
131: 
132: 137 
133: 
134: 
135: 
136: 
137: 139 
138: 
139: 140 
140: 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 168 
168: 169 
169: 171 
170: 
171: 173 
172: 
173: 176 
174: 
175: 
176: 180 
177: 
178: 
179: 
180: 183 
181: 
182: 
183: 184 
184: 185 
185: 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.18s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_tso.oepc_true-unreach-call.c
Converting
Type-checking safe037_tso.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Line: 175
Property: main$tmp_guard0 != FALSE
Line: 176
Assertion: main 175
Line: 177
Line: 178
Line: 181
Line: 182
Line: 185
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 186
Assertion: main 185
Line: 187
Line: 149
Line: 156
Line: 167
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 69
Line: 33
Line: 45
Line: 39
Line: 63
Line: 74
Line: 21
Line: 79
Line: 27
Line: 57
Line: 54
Line: 51
Line: 57
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 76
Property: __global_lock == 1
Line: 77
Assertion: __VERIFIER_atomic_end 76
Line: 78
Line: 79
Line: 81
Property: __global_lock == 0
Line: 82
Assertion: __VERIFIER_atomic_begin 81
Line: 83
Line: 84
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 122
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Line: 163
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: -1
88: 6
89: 0
90: 6
91: 6
92: 6
93: 6
94: 0
95: 6
96: 6
97: 6
98: 6
99: 0
100: 6
101: 0
102: 0
103: -1
104: -1
105: -1
106: -1
107: -1
108: 6
109: 0
110: 6
111: 6
112: 6
113: 6
114: 0
115: 6
116: 6
117: 6
118: 6
119: 0
120: 6
121: 0
122: 0
123: -1
124: -1
125: -1
126: -1
127: -1
128: 6
129: 0
130: 6
131: 6
132: 6
133: 6
134: 0
135: 6
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 0
143: -1
144: -1
145: -1
146: -1
147: -1
148: -1
149: 0
150: -1
151: -1
152: -1
153: -1
154: -1
155: -1
156: 0
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: 0
164: -1
165: -1
166: -1
167: -1
168: -1
169: 6
170: 6
171: 6
172: 6
173: 0
174: 6
175: 0
176: 6
177: 6
178: 6
179: -1
180: -1
181: 2
182: 6
183: -1
184: -1
185: 0
186: 0
187: 0
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1
196: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 90 to 91
Removing from 95 to 96
Removing from 110 to 111
Removing from 115 to 116
Removing from 130 to 131
Removing from 135 to 136
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 175 to 176
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
counter: 0
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
counter: 0
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
counter: 0
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
counter: 0
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
counter: 0
at line 147:  
at line 148:}
counter: 0
at line 154:  
at line 155:}
counter: 0
at line 161:  
at line 162:}
counter: 0
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
counter: 0
at line 187:
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
at line 79:void __VERIFIER_atomic_begin() { 
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
at line 84:
at line 85:void * P0(void *arg)
at line 86:{
at line 87:  __VERIFIER_atomic_begin();
at line 88:  z = 1;
at line 89:  __VERIFIER_atomic_end();
at line 90:
at line 91:
at line 92:  __VERIFIER_atomic_begin();
at line 93:  __unbuffered_p0_EAX = x;
at line 94:  __VERIFIER_atomic_end();
at line 95:
at line 96:
at line 97:  __VERIFIER_atomic_begin();
at line 98:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 99:  __VERIFIER_atomic_end();
at line 100:  return nondet_0();
at line 101:}
at line 102:
at line 103:
at line 104:
at line 105:void * P1(void *arg)
at line 106:{
at line 107:  __VERIFIER_atomic_begin();
at line 108:  x = 1;
at line 109:  __VERIFIER_atomic_end();
at line 110:
at line 111:
at line 112:  __VERIFIER_atomic_begin();
at line 113:  __unbuffered_p1_EAX = y;
at line 114:  __VERIFIER_atomic_end();
at line 115:
at line 116:
at line 117:  __VERIFIER_atomic_begin();
at line 118:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 119:  __VERIFIER_atomic_end();
at line 120:  return nondet_0();
at line 121:}
at line 122:
at line 123:
at line 124:
at line 125:void * P2(void *arg)
at line 126:{
at line 127:  __VERIFIER_atomic_begin();
at line 128:  y = 1;
at line 129:  __VERIFIER_atomic_end();
at line 130:
at line 131:
at line 132:  __VERIFIER_atomic_begin();
at line 133:  __unbuffered_p2_EAX = z;
at line 134:  __VERIFIER_atomic_end();
at line 135:
at line 136:
at line 137:  __VERIFIER_atomic_begin();
at line 138:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 139:  __VERIFIER_atomic_end();
at line 140:  return nondet_0();
at line 141:}
at line 142:
at line 143:
at line 144:
at line 145:void fence()
at line 146:{
at line 147:  
at line 148:}
at line 149:
at line 150:
at line 151:
at line 152:void isync()
at line 153:{
at line 154:  
at line 155:}
at line 156:
at line 157:
at line 158:
at line 159:void lwfence()
at line 160:{
at line 161:  
at line 162:}
at line 163:
at line 164:
at line 165:
at line 166:int main()
at line 167:{
at line 168:pthread_create(NULL, NULL, P0, NULL);
at line 169:pthread_create(NULL, NULL, P1, NULL);
at line 170:pthread_create(NULL, NULL, P2, NULL);
at line 171:  __VERIFIER_atomic_begin();
at line 172:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 173:  __VERIFIER_atomic_end();
at line 174:  __VERIFIER_assume(main$tmp_guard0);
at line 175:
at line 176:
at line 177:  __VERIFIER_atomic_begin();
at line 178:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 179:This likely is a bug in the tool chain. */
at line 180:
at line 181:  __VERIFIER_atomic_end();
at line 182:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 183:This likely is a bug in the tool chain. */
at line 184:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 185:  return 0;
at line 186:}
at line 187:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 148 149
Update CFG: 155 156
Update CFG: 162 163
0: 163 128 108 88 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 149 
149: 
150: 
151: 
152: 
153: 
154: 
155: 156 
156: 
157: 
158: 
159: 
160: 
161: 
162: 163 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 178 
178: 181 
179: 
180: 
181: 182 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
Total line: 187
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 163 129 109 89 81 76 156 149 169 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 
89: 94 
90: 
91: 
92: 
93: 
94: 99 
95: 
96: 
97: 
98: 
99: 101 
100: 
101: 102 
102: 
103: 
104: 
105: 
106: 
107: 
108: 
109: 114 
110: 
111: 
112: 
113: 
114: 119 
115: 
116: 
117: 
118: 
119: 121 
120: 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 134 
130: 
131: 
132: 
133: 
134: 139 
135: 
136: 
137: 
138: 
139: 141 
140: 
141: 142 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 
169: 170 
170: 171 
171: 173 
172: 
173: 175 
174: 
175: 178 
176: 
177: 
178: 182 
179: 
180: 
181: 
182: 185 
183: 
184: 
185: 186 
186: 187 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
196: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.177s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe037_tso.opt_true-unreach-call.c
Converting
Type-checking safe037_tso.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 162 127 107 87 81 76 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 180 
178: 
179: 
180: 181 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg$object - P2
Base name.......: bool arg$object - P1
Base name.......: bool arg$object - pthread_create
Base name.......: bool attr$object - pthread_create
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: bool attr - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: int this_thread_id - pthread_create
Base name.......: int id - __actual_thread_spawn
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool thread - pthread_create
Base name.......: bool main$tmp_guard1 - 
Base name.......: bool arg - P1
Base name.......: bool _opaque_pthread_t - 
Base name.......: int z - 
Base name.......: bool arg - P0
Base name.......: int __unbuffered_p2_EAX - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: int __global_lock - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int y - 
Base name.......: bool arg - P2
Base name.......: bool arg - __actual_thread_spawn
Base name.......: bool main$tmp_guard0 - 
Base name.......: int __unbuffered_cnt - 
Base name.......: int x - 
Line: 168
Line: 169
Line: 170
Line: 171
Line: 172
Line: 173
Line: 174
Property: main$tmp_guard0 != FALSE
Line: 175
Assertion: main 174
Line: 176
Line: 177
Line: 180
Line: 181
Line: 184
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
Line: 185
Assertion: main 184
Line: 186
Line: 148
Line: 155
Line: 166
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 23
Line: 68
Line: 32
Line: 44
Line: 38
Line: 62
Line: 74
Line: 21
Line: 79
Line: 26
Line: 57
Line: 53
Line: 50
Line: 56
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 76
Property: __global_lock == 1
Line: 77
Assertion: __VERIFIER_atomic_end 76
Line: 78
Line: 79
Line: 81
Property: __global_lock == 0
Line: 82
Assertion: __VERIFIER_atomic_begin 81
Line: 83
Line: 84
Line: 87
Line: 88
Line: 89
Line: 90
Line: 91
Line: 92
Line: 93
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 107
Line: 108
Line: 109
Line: 110
Line: 111
Line: 112
Line: 113
Line: 114
Line: 115
Line: 116
Line: 117
Line: 118
Line: 119
Line: 120
Line: 121
Line: 127
Line: 128
Line: 129
Line: 130
Line: 131
Line: 132
Line: 133
Line: 134
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 162
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Property: start_routine == P2
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 3;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);: 4
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
z = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : x 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P2
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP2
y = 1;: 1
__unbuffered_p2_EAX = z;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P2#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P2
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : 
__unbuffered_p0_EAX: : 
__global_lock: : 
__unbuffered_p1_EAX: : 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : 
__unbuffered_cnt: : 
x: : 
DONE goto_program
Test dependency in general
arg$object: P0: 
arg$object: __actual_thread_spawn: 
arg$object: P2: 
arg$object: P1: 
arg$object: pthread_create: 
attr$object: pthread_create: 
_opaque_pthread_attr_t: : 
attr: pthread_create: 
arg: pthread_create: 
this_thread_id: pthread_create: 
id: __actual_thread_spawn: 
thread$object: pthread_create: 
thread$object$object: pthread_create: 
thread: pthread_create: 
main$tmp_guard1: : __unbuffered_p2_EAX __unbuffered_p0_EAX __unbuffered_p1_EAX 
arg: P1: 
_opaque_pthread_t: : 
z: : 
arg: P0: 
__unbuffered_p2_EAX: : z __unbuffered_p0_EAX __unbuffered_p1_EAX 
__unbuffered_p0_EAX: : __unbuffered_p2_EAX __unbuffered_p1_EAX x 
__global_lock: : 
__unbuffered_p1_EAX: : __unbuffered_p2_EAX __unbuffered_p0_EAX y 
y: : 
arg: P2: 
arg: __actual_thread_spawn: 
main$tmp_guard0: : __unbuffered_cnt 
__unbuffered_cnt: : 
x: : 
Start DFS_dependence: 6
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p2_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__unbuffered_p2_EAX
z
__global_lock
__global_lock
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: P2
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: -1
77: -1
78: -1
79: -1
80: -1
81: -1
82: -1
83: -1
84: -1
85: -1
86: -1
87: 6
88: 0
89: 6
90: 6
91: 6
92: 6
93: 0
94: 6
95: 6
96: 6
97: 6
98: 0
99: 6
100: 0
101: 0
102: -1
103: -1
104: -1
105: -1
106: -1
107: 6
108: 0
109: 6
110: 6
111: 6
112: 6
113: 0
114: 6
115: 6
116: 6
117: 6
118: 0
119: 6
120: 0
121: 0
122: -1
123: -1
124: -1
125: -1
126: -1
127: 6
128: 0
129: 6
130: 6
131: 6
132: 6
133: 0
134: 6
135: 6
136: 6
137: 6
138: 0
139: 6
140: 0
141: 0
142: -1
143: -1
144: -1
145: -1
146: -1
147: -1
148: 0
149: -1
150: -1
151: -1
152: -1
153: -1
154: -1
155: 0
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: 0
163: -1
164: -1
165: -1
166: -1
167: -1
168: 6
169: 6
170: 6
171: 6
172: 0
173: 6
174: 0
175: 6
176: 6
177: 6
178: -1
179: -1
180: 2
181: 6
182: -1
183: -1
184: 0
185: 0
186: 0
187: -1
188: -1
189: -1
190: -1
191: -1
192: -1
193: -1
194: -1
195: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;


int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}
void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  z = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P2(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p2_EAX = z;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  pthread_create(NULL, NULL, P2, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 3;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Removing from 89 to 90
Removing from 94 to 95
Removing from 109 to 110
Removing from 114 to 115
Removing from 129 to 130
Removing from 134 to 135
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
cut string: (NULL, NULL, P2, NULL)
after edit call command: pthread_create(NULL, NULL, P2, NULL);
Removing from 174 to 175
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
counter: 0
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
counter: 0
at line 86:  __VERIFIER_atomic_begin();
at line 87:  z = 1;
at line 88:  __VERIFIER_atomic_end();
at line 89:
at line 90:
at line 91:  __VERIFIER_atomic_begin();
at line 92:  __unbuffered_p0_EAX = x;
at line 93:  __VERIFIER_atomic_end();
at line 94:
at line 95:
at line 96:  __VERIFIER_atomic_begin();
at line 97:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 98:  __VERIFIER_atomic_end();
at line 99:  return nondet_0();
at line 100:}
counter: 0
at line 106:  __VERIFIER_atomic_begin();
at line 107:  x = 1;
at line 108:  __VERIFIER_atomic_end();
at line 109:
at line 110:
at line 111:  __VERIFIER_atomic_begin();
at line 112:  __unbuffered_p1_EAX = y;
at line 113:  __VERIFIER_atomic_end();
at line 114:
at line 115:
at line 116:  __VERIFIER_atomic_begin();
at line 117:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 118:  __VERIFIER_atomic_end();
at line 119:  return nondet_0();
at line 120:}
counter: 0
at line 126:  __VERIFIER_atomic_begin();
at line 127:  y = 1;
at line 128:  __VERIFIER_atomic_end();
at line 129:
at line 130:
at line 131:  __VERIFIER_atomic_begin();
at line 132:  __unbuffered_p2_EAX = z;
at line 133:  __VERIFIER_atomic_end();
at line 134:
at line 135:
at line 136:  __VERIFIER_atomic_begin();
at line 137:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 138:  __VERIFIER_atomic_end();
at line 139:  return nondet_0();
at line 140:}
counter: 0
at line 146:  
at line 147:}
counter: 0
at line 153:  
at line 154:}
counter: 0
at line 160:  
at line 161:}
counter: 0
at line 167:pthread_create(NULL, NULL, P0, NULL);
at line 168:pthread_create(NULL, NULL, P1, NULL);
at line 169:pthread_create(NULL, NULL, P2, NULL);
at line 170:  __VERIFIER_atomic_begin();
at line 171:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 172:  __VERIFIER_atomic_end();
at line 173:  __VERIFIER_assume(main$tmp_guard0);
at line 174:
at line 175:
at line 176:  __VERIFIER_atomic_begin();
at line 177:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 178:This likely is a bug in the tool chain. */
at line 179:
at line 180:  __VERIFIER_atomic_end();
at line 181:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 182:This likely is a bug in the tool chain. */
at line 183:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 184:  return 0;
at line 185:}
counter: 0
at line 186:
at line 75:  __VERIFIER_assume(__global_lock==1); 
at line 76:  __global_lock=0; 
at line 77:  return; 
at line 78:}
at line 79:void __VERIFIER_atomic_begin() { 
at line 80:  __VERIFIER_assume(__global_lock==0); 
at line 81:  __global_lock=1; 
at line 82:  return; 
at line 83:}
at line 84:void * P0(void *arg)
at line 85:{
at line 86:  __VERIFIER_atomic_begin();
at line 87:  z = 1;
at line 88:  __VERIFIER_atomic_end();
at line 89:
at line 90:
at line 91:  __VERIFIER_atomic_begin();
at line 92:  __unbuffered_p0_EAX = x;
at line 93:  __VERIFIER_atomic_end();
at line 94:
at line 95:
at line 96:  __VERIFIER_atomic_begin();
at line 97:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 98:  __VERIFIER_atomic_end();
at line 99:  return nondet_0();
at line 100:}
at line 101:
at line 102:
at line 103:
at line 104:void * P1(void *arg)
at line 105:{
at line 106:  __VERIFIER_atomic_begin();
at line 107:  x = 1;
at line 108:  __VERIFIER_atomic_end();
at line 109:
at line 110:
at line 111:  __VERIFIER_atomic_begin();
at line 112:  __unbuffered_p1_EAX = y;
at line 113:  __VERIFIER_atomic_end();
at line 114:
at line 115:
at line 116:  __VERIFIER_atomic_begin();
at line 117:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 118:  __VERIFIER_atomic_end();
at line 119:  return nondet_0();
at line 120:}
at line 121:
at line 122:
at line 123:
at line 124:void * P2(void *arg)
at line 125:{
at line 126:  __VERIFIER_atomic_begin();
at line 127:  y = 1;
at line 128:  __VERIFIER_atomic_end();
at line 129:
at line 130:
at line 131:  __VERIFIER_atomic_begin();
at line 132:  __unbuffered_p2_EAX = z;
at line 133:  __VERIFIER_atomic_end();
at line 134:
at line 135:
at line 136:  __VERIFIER_atomic_begin();
at line 137:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 138:  __VERIFIER_atomic_end();
at line 139:  return nondet_0();
at line 140:}
at line 141:
at line 142:
at line 143:
at line 144:void fence()
at line 145:{
at line 146:  
at line 147:}
at line 148:
at line 149:
at line 150:
at line 151:void isync()
at line 152:{
at line 153:  
at line 154:}
at line 155:
at line 156:
at line 157:
at line 158:void lwfence()
at line 159:{
at line 160:  
at line 161:}
at line 162:
at line 163:
at line 164:
at line 165:int main()
at line 166:{
at line 167:pthread_create(NULL, NULL, P0, NULL);
at line 168:pthread_create(NULL, NULL, P1, NULL);
at line 169:pthread_create(NULL, NULL, P2, NULL);
at line 170:  __VERIFIER_atomic_begin();
at line 171:  main$tmp_guard0 = __unbuffered_cnt == 3;
at line 172:  __VERIFIER_atomic_end();
at line 173:  __VERIFIER_assume(main$tmp_guard0);
at line 174:
at line 175:
at line 176:  __VERIFIER_atomic_begin();
at line 177:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 178:This likely is a bug in the tool chain. */
at line 179:
at line 180:  __VERIFIER_atomic_end();
at line 181:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 182:This likely is a bug in the tool chain. */
at line 183:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
at line 184:  return 0;
at line 185:}
at line 186:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


int __unbuffered_p2_EAX;


int __unbuffered_p2_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;


int z;


int z = 0;


int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}
void * P0(void *arg)
{

  z = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P2(void *arg)
{

  y = 1;




  __unbuffered_p2_EAX = z;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);
pthread_create(NULL, NULL, P2, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 3;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0));
  return 0;
}

Update CFG: 147 148
Update CFG: 154 155
Update CFG: 161 162
0: 162 127 107 87 81 76 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 88 
88: 89 
89: 90 
90: 91 
91: 92 
92: 93 
93: 94 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 108 
108: 109 
109: 110 
110: 111 
111: 112 
112: 113 
113: 114 
114: 115 
115: 116 
116: 117 
117: 118 
118: 119 
119: 120 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 128 
128: 129 
129: 130 
130: 131 
131: 132 
132: 133 
133: 134 
134: 135 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 148 
148: 
149: 
150: 
151: 
152: 
153: 
154: 155 
155: 
156: 
157: 
158: 
159: 
160: 
161: 162 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 171 
171: 172 
172: 173 
173: 174 
174: 175 
175: 176 
176: 177 
177: 180 
178: 
179: 
180: 181 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
Total line: 186
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 162 128 108 88 81 76 155 148 168 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 
65: 
66: 
67: 
68: 
69: 
70: 
71: 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 
80: 
81: 82 
82: 83 
83: 84 
84: 
85: 
86: 
87: 
88: 93 
89: 
90: 
91: 
92: 
93: 98 
94: 
95: 
96: 
97: 
98: 100 
99: 
100: 101 
101: 
102: 
103: 
104: 
105: 
106: 
107: 
108: 113 
109: 
110: 
111: 
112: 
113: 118 
114: 
115: 
116: 
117: 
118: 120 
119: 
120: 121 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 133 
129: 
130: 
131: 
132: 
133: 138 
134: 
135: 
136: 
137: 
138: 140 
139: 
140: 141 
141: 
142: 
143: 
144: 
145: 
146: 
147: 
148: 
149: 
150: 
151: 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
164: 
165: 
166: 
167: 
168: 169 
169: 170 
170: 172 
171: 
172: 174 
173: 
174: 177 
175: 
176: 
177: 181 
178: 
179: 
180: 
181: 184 
182: 
183: 
184: 185 
185: 186 
186: 
187: 
188: 
189: 
190: 
191: 
192: 
193: 
194: 
195: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 546 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
4784 variables, 17108 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.173s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0 && __unbuffered_p2_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) || !(__unbuffered_p2_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
