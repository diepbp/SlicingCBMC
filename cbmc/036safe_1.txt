Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Test dependency in general
Start DFS_dependence: 0
Slice variables: 
Total line: -1
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_power.oepc_true-unreach-call.c
Converting
Type-checking safe036_power.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 129 94 74 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 146 
144: 
145: 
146: 147 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Property: main$tmp_guard0 != FALSE
Line: 141
Assertion: main 140
Line: 142
Line: 143
Line: 146
Line: 147
Line: 150
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 151
Assertion: main 150
Line: 152
Line: 115
Line: 122
Line: 133
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 31
Line: 43
Line: 37
Line: 60
Line: 46
Line: 21
Line: 79
Line: 57
Line: 55
Line: 23
Line: 49
Line: 25
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 62
Property: __global_lock == 1
Line: 63
Assertion: __VERIFIER_atomic_end 62
Line: 64
Line: 65
Line: 67
Property: __global_lock == 0
Line: 68
Assertion: __VERIFIER_atomic_begin 67
Line: 69
Line: 70
Line: 74
Line: 75
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 129
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: 6
75: 0
76: 6
77: 6
78: 6
79: 6
80: 0
81: 6
82: 6
83: 6
84: 6
85: 0
86: 6
87: 0
88: 0
89: -1
90: -1
91: -1
92: -1
93: -1
94: 6
95: 0
96: 6
97: 6
98: 6
99: 6
100: 0
101: 6
102: 6
103: 6
104: 6
105: 0
106: 6
107: 0
108: 0
109: -1
110: -1
111: -1
112: -1
113: -1
114: -1
115: 0
116: -1
117: -1
118: -1
119: -1
120: -1
121: -1
122: 0
123: -1
124: -1
125: -1
126: -1
127: -1
128: -1
129: 0
130: -1
131: -1
132: -1
133: -1
134: -1
135: 6
136: 6
137: 6
138: 0
139: 6
140: 0
141: 6
142: 6
143: 6
144: -1
145: -1
146: 2
147: 6
148: -1
149: -1
150: 0
151: 0
152: 0
153: -1
154: -1
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif


int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 76 to 77
Removing from 81 to 82
Removing from 96 to 97
Removing from 101 to 102
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 140 to 141
at line 61:  __VERIFIER_assume(__global_lock==1); 
at line 62:  __global_lock=0; 
at line 63:  return; 
at line 64:}
counter: 0
at line 66:  __VERIFIER_assume(__global_lock==0); 
at line 67:  __global_lock=1; 
at line 68:  return; 
at line 69:}
counter: 0
at line 73:  __VERIFIER_atomic_begin();
at line 74:  y = 1;
at line 75:  __VERIFIER_atomic_end();
at line 76:
at line 77:
at line 78:  __VERIFIER_atomic_begin();
at line 79:  __unbuffered_p0_EAX = x;
at line 80:  __VERIFIER_atomic_end();
at line 81:
at line 82:
at line 83:  __VERIFIER_atomic_begin();
at line 84:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 85:  __VERIFIER_atomic_end();
at line 86:  return nondet_0();
at line 87:}
counter: 0
at line 93:  __VERIFIER_atomic_begin();
at line 94:  x = 1;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_p1_EAX = y;
at line 100:  __VERIFIER_atomic_end();
at line 101:
at line 102:
at line 103:  __VERIFIER_atomic_begin();
at line 104:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 105:  __VERIFIER_atomic_end();
at line 106:  return nondet_0();
at line 107:}
counter: 0
at line 113:  
at line 114:}
counter: 0
at line 120:  
at line 121:}
counter: 0
at line 127:  
at line 128:}
counter: 0
at line 134:pthread_create(NULL, NULL, P0, NULL);
at line 135:pthread_create(NULL, NULL, P1, NULL);
at line 136:  __VERIFIER_atomic_begin();
at line 137:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 138:  __VERIFIER_atomic_end();
at line 139:  __VERIFIER_assume(main$tmp_guard0);
at line 140:
at line 141:
at line 142:  __VERIFIER_atomic_begin();
at line 143:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 144:This likely is a bug in the tool chain. */
at line 145:
at line 146:  __VERIFIER_atomic_end();
at line 147:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 148:This likely is a bug in the tool chain. */
at line 149:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 150:  return 0;
at line 151:}
counter: 0
at line 152:
at line 61:  __VERIFIER_assume(__global_lock==1); 
at line 62:  __global_lock=0; 
at line 63:  return; 
at line 64:}
at line 65:void __VERIFIER_atomic_begin() { 
at line 66:  __VERIFIER_assume(__global_lock==0); 
at line 67:  __global_lock=1; 
at line 68:  return; 
at line 69:}
at line 70:
at line 71:void * P0(void *arg)
at line 72:{
at line 73:  __VERIFIER_atomic_begin();
at line 74:  y = 1;
at line 75:  __VERIFIER_atomic_end();
at line 76:
at line 77:
at line 78:  __VERIFIER_atomic_begin();
at line 79:  __unbuffered_p0_EAX = x;
at line 80:  __VERIFIER_atomic_end();
at line 81:
at line 82:
at line 83:  __VERIFIER_atomic_begin();
at line 84:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 85:  __VERIFIER_atomic_end();
at line 86:  return nondet_0();
at line 87:}
at line 88:
at line 89:
at line 90:
at line 91:void * P1(void *arg)
at line 92:{
at line 93:  __VERIFIER_atomic_begin();
at line 94:  x = 1;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_p1_EAX = y;
at line 100:  __VERIFIER_atomic_end();
at line 101:
at line 102:
at line 103:  __VERIFIER_atomic_begin();
at line 104:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 105:  __VERIFIER_atomic_end();
at line 106:  return nondet_0();
at line 107:}
at line 108:
at line 109:
at line 110:
at line 111:void fence()
at line 112:{
at line 113:  
at line 114:}
at line 115:
at line 116:
at line 117:
at line 118:void isync()
at line 119:{
at line 120:  
at line 121:}
at line 122:
at line 123:
at line 124:
at line 125:void lwfence()
at line 126:{
at line 127:  
at line 128:}
at line 129:
at line 130:
at line 131:
at line 132:int main()
at line 133:{
at line 134:pthread_create(NULL, NULL, P0, NULL);
at line 135:pthread_create(NULL, NULL, P1, NULL);
at line 136:  __VERIFIER_atomic_begin();
at line 137:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 138:  __VERIFIER_atomic_end();
at line 139:  __VERIFIER_assume(main$tmp_guard0);
at line 140:
at line 141:
at line 142:  __VERIFIER_atomic_begin();
at line 143:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 144:This likely is a bug in the tool chain. */
at line 145:
at line 146:  __VERIFIER_atomic_end();
at line 147:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 148:This likely is a bug in the tool chain. */
at line 149:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 150:  return 0;
at line 151:}
at line 152:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif


int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 114 115
Update CFG: 121 122
Update CFG: 128 129
0: 129 94 74 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 115 
115: 
116: 
117: 
118: 
119: 
120: 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 146 
144: 
145: 
146: 147 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 129 95 75 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 
75: 80 
76: 
77: 
78: 
79: 
80: 85 
81: 
82: 
83: 
84: 
85: 87 
86: 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 100 
96: 
97: 
98: 
99: 
100: 105 
101: 
102: 
103: 
104: 
105: 107 
106: 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 138 
137: 
138: 140 
139: 
140: 143 
141: 
142: 
143: 147 
144: 
145: 
146: 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.094s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_power.opt_true-unreach-call.c
Converting
Type-checking safe036_power.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Property: main$tmp_guard0 != FALSE
Line: 142
Assertion: main 141
Line: 143
Line: 144
Line: 147
Line: 148
Line: 151
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 152
Assertion: main 151
Line: 153
Line: 116
Line: 123
Line: 134
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 32
Line: 44
Line: 38
Line: 61
Line: 47
Line: 21
Line: 79
Line: 57
Line: 56
Line: 23
Line: 50
Line: 26
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 63
Property: __global_lock == 1
Line: 64
Assertion: __VERIFIER_atomic_end 63
Line: 65
Line: 66
Line: 68
Property: __global_lock == 0
Line: 69
Assertion: __VERIFIER_atomic_begin 68
Line: 70
Line: 71
Line: 75
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 130
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: 6
76: 0
77: 6
78: 6
79: 6
80: 6
81: 0
82: 6
83: 6
84: 6
85: 6
86: 0
87: 6
88: 0
89: 0
90: -1
91: -1
92: -1
93: -1
94: -1
95: 6
96: 0
97: 6
98: 6
99: 6
100: 6
101: 0
102: 6
103: 6
104: 6
105: 6
106: 0
107: 6
108: 0
109: 0
110: -1
111: -1
112: -1
113: -1
114: -1
115: -1
116: 0
117: -1
118: -1
119: -1
120: -1
121: -1
122: -1
123: 0
124: -1
125: -1
126: -1
127: -1
128: -1
129: -1
130: 0
131: -1
132: -1
133: -1
134: -1
135: -1
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 6
143: 6
144: 6
145: -1
146: -1
147: 2
148: 6
149: -1
150: -1
151: 0
152: 0
153: 0
154: -1
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 77 to 78
Removing from 82 to 83
Removing from 97 to 98
Removing from 102 to 103
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 141 to 142
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
counter: 0
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
counter: 0
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
counter: 0
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
counter: 0
at line 114:  
at line 115:}
counter: 0
at line 121:  
at line 122:}
counter: 0
at line 128:  
at line 129:}
counter: 0
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
counter: 0
at line 153:
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
at line 66:void __VERIFIER_atomic_begin() { 
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
at line 71:
at line 72:void * P0(void *arg)
at line 73:{
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
at line 89:
at line 90:
at line 91:
at line 92:void * P1(void *arg)
at line 93:{
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
at line 109:
at line 110:
at line 111:
at line 112:void fence()
at line 113:{
at line 114:  
at line 115:}
at line 116:
at line 117:
at line 118:
at line 119:void isync()
at line 120:{
at line 121:  
at line 122:}
at line 123:
at line 124:
at line 125:
at line 126:void lwfence()
at line 127:{
at line 128:  
at line 129:}
at line 130:
at line 131:
at line 132:
at line 133:int main()
at line 134:{
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
at line 153:

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 115 116
Update CFG: 122 123
Update CFG: 129 130
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 116 
116: 
117: 
118: 
119: 
120: 
121: 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 96 76 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 
76: 81 
77: 
78: 
79: 
80: 
81: 86 
82: 
83: 
84: 
85: 
86: 88 
87: 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: 101 
97: 
98: 
99: 
100: 
101: 106 
102: 
103: 
104: 
105: 
106: 108 
107: 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 139 
138: 
139: 141 
140: 
141: 144 
142: 
143: 
144: 148 
145: 
146: 
147: 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.097s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_pso.oepc_true-unreach-call.c
Converting
Type-checking safe036_pso.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 129 94 74 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 146 
144: 
145: 
146: 147 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 135
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Property: main$tmp_guard0 != FALSE
Line: 141
Assertion: main 140
Line: 142
Line: 143
Line: 146
Line: 147
Line: 150
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 151
Assertion: main 150
Line: 152
Line: 115
Line: 122
Line: 133
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 31
Line: 43
Line: 37
Line: 60
Line: 46
Line: 21
Line: 79
Line: 57
Line: 55
Line: 23
Line: 49
Line: 25
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 62
Property: __global_lock == 1
Line: 63
Assertion: __VERIFIER_atomic_end 62
Line: 64
Line: 65
Line: 67
Property: __global_lock == 0
Line: 68
Assertion: __VERIFIER_atomic_begin 67
Line: 69
Line: 70
Line: 74
Line: 75
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 94
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 129
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: 6
75: 0
76: 6
77: 6
78: 6
79: 6
80: 0
81: 6
82: 6
83: 6
84: 6
85: 0
86: 6
87: 0
88: 0
89: -1
90: -1
91: -1
92: -1
93: -1
94: 6
95: 0
96: 6
97: 6
98: 6
99: 6
100: 0
101: 6
102: 6
103: 6
104: 6
105: 0
106: 6
107: 0
108: 0
109: -1
110: -1
111: -1
112: -1
113: -1
114: -1
115: 0
116: -1
117: -1
118: -1
119: -1
120: -1
121: -1
122: 0
123: -1
124: -1
125: -1
126: -1
127: -1
128: -1
129: 0
130: -1
131: -1
132: -1
133: -1
134: -1
135: 6
136: 6
137: 6
138: 0
139: 6
140: 0
141: 6
142: 6
143: 6
144: -1
145: -1
146: 2
147: 6
148: -1
149: -1
150: 0
151: 0
152: 0
153: -1
154: -1
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 76 to 77
Removing from 81 to 82
Removing from 96 to 97
Removing from 101 to 102
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 140 to 141
at line 61:  __VERIFIER_assume(__global_lock==1); 
at line 62:  __global_lock=0; 
at line 63:  return; 
at line 64:}
counter: 0
at line 66:  __VERIFIER_assume(__global_lock==0); 
at line 67:  __global_lock=1; 
at line 68:  return; 
at line 69:}
counter: 0
at line 73:  __VERIFIER_atomic_begin();
at line 74:  y = 1;
at line 75:  __VERIFIER_atomic_end();
at line 76:
at line 77:
at line 78:  __VERIFIER_atomic_begin();
at line 79:  __unbuffered_p0_EAX = x;
at line 80:  __VERIFIER_atomic_end();
at line 81:
at line 82:
at line 83:  __VERIFIER_atomic_begin();
at line 84:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 85:  __VERIFIER_atomic_end();
at line 86:  return nondet_0();
at line 87:}
counter: 0
at line 93:  __VERIFIER_atomic_begin();
at line 94:  x = 1;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_p1_EAX = y;
at line 100:  __VERIFIER_atomic_end();
at line 101:
at line 102:
at line 103:  __VERIFIER_atomic_begin();
at line 104:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 105:  __VERIFIER_atomic_end();
at line 106:  return nondet_0();
at line 107:}
counter: 0
at line 113:  
at line 114:}
counter: 0
at line 120:  
at line 121:}
counter: 0
at line 127:  
at line 128:}
counter: 0
at line 134:pthread_create(NULL, NULL, P0, NULL);
at line 135:pthread_create(NULL, NULL, P1, NULL);
at line 136:  __VERIFIER_atomic_begin();
at line 137:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 138:  __VERIFIER_atomic_end();
at line 139:  __VERIFIER_assume(main$tmp_guard0);
at line 140:
at line 141:
at line 142:  __VERIFIER_atomic_begin();
at line 143:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 144:This likely is a bug in the tool chain. */
at line 145:
at line 146:  __VERIFIER_atomic_end();
at line 147:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 148:This likely is a bug in the tool chain. */
at line 149:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 150:  return 0;
at line 151:}
counter: 0
at line 152:
at line 61:  __VERIFIER_assume(__global_lock==1); 
at line 62:  __global_lock=0; 
at line 63:  return; 
at line 64:}
at line 65:void __VERIFIER_atomic_begin() { 
at line 66:  __VERIFIER_assume(__global_lock==0); 
at line 67:  __global_lock=1; 
at line 68:  return; 
at line 69:}
at line 70:
at line 71:void * P0(void *arg)
at line 72:{
at line 73:  __VERIFIER_atomic_begin();
at line 74:  y = 1;
at line 75:  __VERIFIER_atomic_end();
at line 76:
at line 77:
at line 78:  __VERIFIER_atomic_begin();
at line 79:  __unbuffered_p0_EAX = x;
at line 80:  __VERIFIER_atomic_end();
at line 81:
at line 82:
at line 83:  __VERIFIER_atomic_begin();
at line 84:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 85:  __VERIFIER_atomic_end();
at line 86:  return nondet_0();
at line 87:}
at line 88:
at line 89:
at line 90:
at line 91:void * P1(void *arg)
at line 92:{
at line 93:  __VERIFIER_atomic_begin();
at line 94:  x = 1;
at line 95:  __VERIFIER_atomic_end();
at line 96:
at line 97:
at line 98:  __VERIFIER_atomic_begin();
at line 99:  __unbuffered_p1_EAX = y;
at line 100:  __VERIFIER_atomic_end();
at line 101:
at line 102:
at line 103:  __VERIFIER_atomic_begin();
at line 104:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 105:  __VERIFIER_atomic_end();
at line 106:  return nondet_0();
at line 107:}
at line 108:
at line 109:
at line 110:
at line 111:void fence()
at line 112:{
at line 113:  
at line 114:}
at line 115:
at line 116:
at line 117:
at line 118:void isync()
at line 119:{
at line 120:  
at line 121:}
at line 122:
at line 123:
at line 124:
at line 125:void lwfence()
at line 126:{
at line 127:  
at line 128:}
at line 129:
at line 130:
at line 131:
at line 132:int main()
at line 133:{
at line 134:pthread_create(NULL, NULL, P0, NULL);
at line 135:pthread_create(NULL, NULL, P1, NULL);
at line 136:  __VERIFIER_atomic_begin();
at line 137:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 138:  __VERIFIER_atomic_end();
at line 139:  __VERIFIER_assume(main$tmp_guard0);
at line 140:
at line 141:
at line 142:  __VERIFIER_atomic_begin();
at line 143:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 144:This likely is a bug in the tool chain. */
at line 145:
at line 146:  __VERIFIER_atomic_end();
at line 147:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 148:This likely is a bug in the tool chain. */
at line 149:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 150:  return 0;
at line 151:}
at line 152:

#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 114 115
Update CFG: 121 122
Update CFG: 128 129
0: 129 94 74 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 75 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 95 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 115 
115: 
116: 
117: 
118: 
119: 
120: 
121: 122 
122: 
123: 
124: 
125: 
126: 
127: 
128: 129 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 146 
144: 
145: 
146: 147 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
Total line: 152
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 129 95 75 67 62 122 115 135 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 63 
63: 64 
64: 65 
65: 
66: 
67: 68 
68: 69 
69: 70 
70: 
71: 
72: 
73: 
74: 
75: 80 
76: 
77: 
78: 
79: 
80: 85 
81: 
82: 
83: 
84: 
85: 87 
86: 
87: 88 
88: 
89: 
90: 
91: 
92: 
93: 
94: 
95: 100 
96: 
97: 
98: 
99: 
100: 105 
101: 
102: 
103: 
104: 
105: 107 
106: 
107: 108 
108: 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 136 
136: 138 
137: 
138: 140 
139: 
140: 143 
141: 
142: 
143: 147 
144: 
145: 
146: 
147: 150 
148: 
149: 
150: 151 
151: 152 
152: 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.102s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_pso.opt_true-unreach-call.c
Converting
Type-checking safe036_pso.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Property: main$tmp_guard0 != FALSE
Line: 143
Assertion: main 142
Line: 144
Line: 145
Line: 148
Line: 149
Line: 152
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 153
Assertion: main 152
Line: 154
Line: 117
Line: 124
Line: 135
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 33
Line: 45
Line: 39
Line: 62
Line: 48
Line: 21
Line: 79
Line: 57
Line: 23
Line: 51
Line: 27
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 64
Property: __global_lock == 1
Line: 65
Assertion: __VERIFIER_atomic_end 64
Line: 66
Line: 67
Line: 69
Property: __global_lock == 0
Line: 70
Assertion: __VERIFIER_atomic_begin 69
Line: 71
Line: 72
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 90
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 110
Line: 131
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: 6
77: 0
78: 6
79: 6
80: 6
81: 6
82: 0
83: 6
84: 6
85: 6
86: 6
87: 0
88: 6
89: 0
90: 0
91: -1
92: -1
93: -1
94: -1
95: -1
96: 6
97: 0
98: 6
99: 6
100: 6
101: 6
102: 0
103: 6
104: 6
105: 6
106: 6
107: 0
108: 6
109: 0
110: 0
111: -1
112: -1
113: -1
114: -1
115: -1
116: -1
117: 0
118: -1
119: -1
120: -1
121: -1
122: -1
123: -1
124: 0
125: -1
126: -1
127: -1
128: -1
129: -1
130: -1
131: 0
132: -1
133: -1
134: -1
135: -1
136: -1
137: 6
138: 6
139: 6
140: 0
141: 6
142: 0
143: 6
144: 6
145: 6
146: -1
147: -1
148: 2
149: 6
150: -1
151: -1
152: 0
153: 0
154: 0
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 78 to 79
Removing from 83 to 84
Removing from 98 to 99
Removing from 103 to 104
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 142 to 143
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
counter: 0
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
counter: 0
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
counter: 0
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
counter: 0
at line 115:  
at line 116:}
counter: 0
at line 122:  
at line 123:}
counter: 0
at line 129:  
at line 130:}
counter: 0
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
counter: 0
at line 154:
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
at line 67:void __VERIFIER_atomic_begin() { 
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
at line 72:
at line 73:void * P0(void *arg)
at line 74:{
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
at line 90:
at line 91:
at line 92:
at line 93:void * P1(void *arg)
at line 94:{
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
at line 110:
at line 111:
at line 112:
at line 113:void fence()
at line 114:{
at line 115:  
at line 116:}
at line 117:
at line 118:
at line 119:
at line 120:void isync()
at line 121:{
at line 122:  
at line 123:}
at line 124:
at line 125:
at line 126:
at line 127:void lwfence()
at line 128:{
at line 129:  
at line 130:}
at line 131:
at line 132:
at line 133:
at line 134:int main()
at line 135:{
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
at line 154:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 116 117
Update CFG: 123 124
Update CFG: 130 131
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 117 
117: 
118: 
119: 
120: 
121: 
122: 
123: 124 
124: 
125: 
126: 
127: 
128: 
129: 
130: 131 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 97 77 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 
77: 82 
78: 
79: 
80: 
81: 
82: 87 
83: 
84: 
85: 
86: 
87: 89 
88: 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 
97: 102 
98: 
99: 
100: 
101: 
102: 107 
103: 
104: 
105: 
106: 
107: 109 
108: 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 140 
139: 
140: 142 
141: 
142: 145 
143: 
144: 
145: 149 
146: 
147: 
148: 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.099s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_rmo.oepc_true-unreach-call.c
Converting
Type-checking safe036_rmo.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Property: main$tmp_guard0 != FALSE
Line: 143
Assertion: main 142
Line: 144
Line: 145
Line: 148
Line: 149
Line: 152
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 153
Assertion: main 152
Line: 154
Line: 117
Line: 124
Line: 135
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 33
Line: 45
Line: 39
Line: 62
Line: 48
Line: 21
Line: 79
Line: 57
Line: 23
Line: 51
Line: 27
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 64
Property: __global_lock == 1
Line: 65
Assertion: __VERIFIER_atomic_end 64
Line: 66
Line: 67
Line: 69
Property: __global_lock == 0
Line: 70
Assertion: __VERIFIER_atomic_begin 69
Line: 71
Line: 72
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 90
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 110
Line: 131
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: 6
77: 0
78: 6
79: 6
80: 6
81: 6
82: 0
83: 6
84: 6
85: 6
86: 6
87: 0
88: 6
89: 0
90: 0
91: -1
92: -1
93: -1
94: -1
95: -1
96: 6
97: 0
98: 6
99: 6
100: 6
101: 6
102: 0
103: 6
104: 6
105: 6
106: 6
107: 0
108: 6
109: 0
110: 0
111: -1
112: -1
113: -1
114: -1
115: -1
116: -1
117: 0
118: -1
119: -1
120: -1
121: -1
122: -1
123: -1
124: 0
125: -1
126: -1
127: -1
128: -1
129: -1
130: -1
131: 0
132: -1
133: -1
134: -1
135: -1
136: -1
137: 6
138: 6
139: 6
140: 0
141: 6
142: 0
143: 6
144: 6
145: 6
146: -1
147: -1
148: 2
149: 6
150: -1
151: -1
152: 0
153: 0
154: 0
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 78 to 79
Removing from 83 to 84
Removing from 98 to 99
Removing from 103 to 104
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 142 to 143
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
counter: 0
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
counter: 0
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
counter: 0
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
counter: 0
at line 115:  
at line 116:}
counter: 0
at line 122:  
at line 123:}
counter: 0
at line 129:  
at line 130:}
counter: 0
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
counter: 0
at line 154:
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
at line 67:void __VERIFIER_atomic_begin() { 
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
at line 72:
at line 73:void * P0(void *arg)
at line 74:{
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
at line 90:
at line 91:
at line 92:
at line 93:void * P1(void *arg)
at line 94:{
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
at line 110:
at line 111:
at line 112:
at line 113:void fence()
at line 114:{
at line 115:  
at line 116:}
at line 117:
at line 118:
at line 119:
at line 120:void isync()
at line 121:{
at line 122:  
at line 123:}
at line 124:
at line 125:
at line 126:
at line 127:void lwfence()
at line 128:{
at line 129:  
at line 130:}
at line 131:
at line 132:
at line 133:
at line 134:int main()
at line 135:{
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
at line 154:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 116 117
Update CFG: 123 124
Update CFG: 130 131
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 117 
117: 
118: 
119: 
120: 
121: 
122: 
123: 124 
124: 
125: 
126: 
127: 
128: 
129: 
130: 131 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 97 77 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 
77: 82 
78: 
79: 
80: 
81: 
82: 87 
83: 
84: 
85: 
86: 
87: 89 
88: 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 
97: 102 
98: 
99: 
100: 
101: 
102: 107 
103: 
104: 
105: 
106: 
107: 109 
108: 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 140 
139: 
140: 142 
141: 
142: 145 
143: 
144: 
145: 149 
146: 
147: 
148: 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.094s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_rmo.opt_true-unreach-call.c
Converting
Type-checking safe036_rmo.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Line: 142
Property: main$tmp_guard0 != FALSE
Line: 143
Assertion: main 142
Line: 144
Line: 145
Line: 148
Line: 149
Line: 152
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 153
Assertion: main 152
Line: 154
Line: 117
Line: 124
Line: 135
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 33
Line: 45
Line: 39
Line: 62
Line: 48
Line: 21
Line: 79
Line: 57
Line: 23
Line: 51
Line: 27
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 64
Property: __global_lock == 1
Line: 65
Assertion: __VERIFIER_atomic_end 64
Line: 66
Line: 67
Line: 69
Property: __global_lock == 0
Line: 70
Assertion: __VERIFIER_atomic_begin 69
Line: 71
Line: 72
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 90
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 110
Line: 131
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: -1
76: 6
77: 0
78: 6
79: 6
80: 6
81: 6
82: 0
83: 6
84: 6
85: 6
86: 6
87: 0
88: 6
89: 0
90: 0
91: -1
92: -1
93: -1
94: -1
95: -1
96: 6
97: 0
98: 6
99: 6
100: 6
101: 6
102: 0
103: 6
104: 6
105: 6
106: 6
107: 0
108: 6
109: 0
110: 0
111: -1
112: -1
113: -1
114: -1
115: -1
116: -1
117: 0
118: -1
119: -1
120: -1
121: -1
122: -1
123: -1
124: 0
125: -1
126: -1
127: -1
128: -1
129: -1
130: -1
131: 0
132: -1
133: -1
134: -1
135: -1
136: -1
137: 6
138: 6
139: 6
140: 0
141: 6
142: 0
143: 6
144: 6
145: 6
146: -1
147: -1
148: 2
149: 6
150: -1
151: -1
152: 0
153: 0
154: 0
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1
163: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 78 to 79
Removing from 83 to 84
Removing from 98 to 99
Removing from 103 to 104
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 142 to 143
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
counter: 0
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
counter: 0
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
counter: 0
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
counter: 0
at line 115:  
at line 116:}
counter: 0
at line 122:  
at line 123:}
counter: 0
at line 129:  
at line 130:}
counter: 0
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
counter: 0
at line 154:
at line 63:  __VERIFIER_assume(__global_lock==1); 
at line 64:  __global_lock=0; 
at line 65:  return; 
at line 66:}
at line 67:void __VERIFIER_atomic_begin() { 
at line 68:  __VERIFIER_assume(__global_lock==0); 
at line 69:  __global_lock=1; 
at line 70:  return; 
at line 71:}
at line 72:
at line 73:void * P0(void *arg)
at line 74:{
at line 75:  __VERIFIER_atomic_begin();
at line 76:  y = 1;
at line 77:  __VERIFIER_atomic_end();
at line 78:
at line 79:
at line 80:  __VERIFIER_atomic_begin();
at line 81:  __unbuffered_p0_EAX = x;
at line 82:  __VERIFIER_atomic_end();
at line 83:
at line 84:
at line 85:  __VERIFIER_atomic_begin();
at line 86:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 87:  __VERIFIER_atomic_end();
at line 88:  return nondet_0();
at line 89:}
at line 90:
at line 91:
at line 92:
at line 93:void * P1(void *arg)
at line 94:{
at line 95:  __VERIFIER_atomic_begin();
at line 96:  x = 1;
at line 97:  __VERIFIER_atomic_end();
at line 98:
at line 99:
at line 100:  __VERIFIER_atomic_begin();
at line 101:  __unbuffered_p1_EAX = y;
at line 102:  __VERIFIER_atomic_end();
at line 103:
at line 104:
at line 105:  __VERIFIER_atomic_begin();
at line 106:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 107:  __VERIFIER_atomic_end();
at line 108:  return nondet_0();
at line 109:}
at line 110:
at line 111:
at line 112:
at line 113:void fence()
at line 114:{
at line 115:  
at line 116:}
at line 117:
at line 118:
at line 119:
at line 120:void isync()
at line 121:{
at line 122:  
at line 123:}
at line 124:
at line 125:
at line 126:
at line 127:void lwfence()
at line 128:{
at line 129:  
at line 130:}
at line 131:
at line 132:
at line 133:
at line 134:int main()
at line 135:{
at line 136:pthread_create(NULL, NULL, P0, NULL);
at line 137:pthread_create(NULL, NULL, P1, NULL);
at line 138:  __VERIFIER_atomic_begin();
at line 139:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 140:  __VERIFIER_atomic_end();
at line 141:  __VERIFIER_assume(main$tmp_guard0);
at line 142:
at line 143:
at line 144:  __VERIFIER_atomic_begin();
at line 145:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 146:This likely is a bug in the tool chain. */
at line 147:
at line 148:  __VERIFIER_atomic_end();
at line 149:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 150:This likely is a bug in the tool chain. */
at line 151:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 152:  return 0;
at line 153:}
at line 154:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif




int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 116 117
Update CFG: 123 124
Update CFG: 130 131
0: 131 96 76 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 117 
117: 
118: 
119: 
120: 
121: 
122: 
123: 124 
124: 
125: 
126: 
127: 
128: 
129: 
130: 131 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 145 
145: 148 
146: 
147: 
148: 149 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
Total line: 154
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 131 97 77 69 64 124 117 137 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 
64: 65 
65: 66 
66: 67 
67: 
68: 
69: 70 
70: 71 
71: 72 
72: 
73: 
74: 
75: 
76: 
77: 82 
78: 
79: 
80: 
81: 
82: 87 
83: 
84: 
85: 
86: 
87: 89 
88: 
89: 90 
90: 
91: 
92: 
93: 
94: 
95: 
96: 
97: 102 
98: 
99: 
100: 
101: 
102: 107 
103: 
104: 
105: 
106: 
107: 109 
108: 
109: 110 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 
137: 138 
138: 140 
139: 
140: 142 
141: 
142: 145 
143: 
144: 
145: 149 
146: 
147: 
148: 
149: 152 
150: 
151: 
152: 153 
153: 154 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
163: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.098s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_tso.oepc_true-unreach-call.c
Converting
Type-checking safe036_tso.oepc_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Property: main$tmp_guard0 != FALSE
Line: 142
Assertion: main 141
Line: 143
Line: 144
Line: 147
Line: 148
Line: 151
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 152
Assertion: main 151
Line: 153
Line: 116
Line: 123
Line: 134
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 32
Line: 44
Line: 38
Line: 61
Line: 47
Line: 21
Line: 79
Line: 57
Line: 56
Line: 23
Line: 50
Line: 26
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 63
Property: __global_lock == 1
Line: 64
Assertion: __VERIFIER_atomic_end 63
Line: 65
Line: 66
Line: 68
Property: __global_lock == 0
Line: 69
Assertion: __VERIFIER_atomic_begin 68
Line: 70
Line: 71
Line: 75
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 130
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: 6
76: 0
77: 6
78: 6
79: 6
80: 6
81: 0
82: 6
83: 6
84: 6
85: 6
86: 0
87: 6
88: 0
89: 0
90: -1
91: -1
92: -1
93: -1
94: -1
95: 6
96: 0
97: 6
98: 6
99: 6
100: 6
101: 0
102: 6
103: 6
104: 6
105: 6
106: 0
107: 6
108: 0
109: 0
110: -1
111: -1
112: -1
113: -1
114: -1
115: -1
116: 0
117: -1
118: -1
119: -1
120: -1
121: -1
122: -1
123: 0
124: -1
125: -1
126: -1
127: -1
128: -1
129: -1
130: 0
131: -1
132: -1
133: -1
134: -1
135: -1
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 6
143: 6
144: 6
145: -1
146: -1
147: 2
148: 6
149: -1
150: -1
151: 0
152: 0
153: 0
154: -1
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 77 to 78
Removing from 82 to 83
Removing from 97 to 98
Removing from 102 to 103
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 141 to 142
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
counter: 0
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
counter: 0
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
counter: 0
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
counter: 0
at line 114:  
at line 115:}
counter: 0
at line 121:  
at line 122:}
counter: 0
at line 128:  
at line 129:}
counter: 0
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
counter: 0
at line 153:
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
at line 66:void __VERIFIER_atomic_begin() { 
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
at line 71:
at line 72:void * P0(void *arg)
at line 73:{
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
at line 89:
at line 90:
at line 91:
at line 92:void * P1(void *arg)
at line 93:{
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
at line 109:
at line 110:
at line 111:
at line 112:void fence()
at line 113:{
at line 114:  
at line 115:}
at line 116:
at line 117:
at line 118:
at line 119:void isync()
at line 120:{
at line 121:  
at line 122:}
at line 123:
at line 124:
at line 125:
at line 126:void lwfence()
at line 127:{
at line 128:  
at line 129:}
at line 130:
at line 131:
at line 132:
at line 133:int main()
at line 134:{
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
at line 153:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 115 116
Update CFG: 122 123
Update CFG: 129 130
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 116 
116: 
117: 
118: 
119: 
120: 
121: 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 96 76 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 
76: 81 
77: 
78: 
79: 
80: 
81: 86 
82: 
83: 
84: 
85: 
86: 88 
87: 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: 101 
97: 
98: 
99: 
100: 
101: 106 
102: 
103: 
104: 
105: 
106: 108 
107: 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 139 
138: 
139: 141 
140: 
141: 144 
142: 
143: 
144: 148 
145: 
146: 
147: 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.154s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
Parsing /Users/diepbp/Documents/workspace/SlicingCBMC/test/pthread-wmm/safe036_tso.opt_true-unreach-call.c
Converting
Type-checking safe036_tso.opt_true-unreach-call
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Base name.......: bool attr$object - pthread_create
Base name.......: bool arg$object - P0
Base name.......: bool arg$object - pthread_create
we have a thread
Base name.......: bool thread$object - pthread_create
Base name.......: bool arg$object - __actual_thread_spawn
Base name.......: bool arg - __actual_thread_spawn
Base name.......: int id - __actual_thread_spawn
Base name.......: bool thread - pthread_create
Base name.......: bool arg - pthread_create
Base name.......: bool arg$object - P1
Base name.......: bool thread$object$object - pthread_create
Base name.......: bool _opaque_pthread_t - 
Base name.......: int __unbuffered_p0_EAX - 
Base name.......: bool main$tmp_guard0 - 
Base name.......: bool arg - P0
Base name.......: bool _opaque_pthread_attr_t - 
Base name.......: int __unbuffered_p1_EAX - 
Base name.......: int __global_lock - 
Base name.......: bool arg - P1
Base name.......: bool main$tmp_guard1 - 
Base name.......: int y - 
Base name.......: int this_thread_id - pthread_create
Base name.......: bool attr - pthread_create
Base name.......: int x - 
Base name.......: int __unbuffered_cnt - 
Line: 136
Line: 137
Line: 138
Line: 139
Line: 140
Line: 141
Property: main$tmp_guard0 != FALSE
Line: 142
Assertion: main 141
Line: 143
Line: 144
Line: 147
Line: 148
Line: 151
Property: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
Line: 152
Assertion: main 151
Line: 153
Line: 116
Line: 123
Line: 134
Line: 22
Line: 33
Line: 31
Line: 32
Line: 30
Line: 34
Line: 35
Line: 32
Line: 44
Line: 38
Line: 61
Line: 47
Line: 21
Line: 79
Line: 57
Line: 56
Line: 23
Line: 50
Line: 26
Line: 32
Line: 33
Line: 34
Line: 35
Line: 36
Line: 38
Property: !(thread != ((struct _opaque_pthread_t **)NULL))
Line: 42
Line: 48
Property: !(attr != ((const struct _opaque_pthread_attr_t *)NULL))
Line: 49
Line: 51
Line: 52
Line: 63
Property: __global_lock == 1
Line: 64
Assertion: __VERIFIER_atomic_end 63
Line: 65
Line: 66
Line: 68
Property: __global_lock == 0
Line: 69
Assertion: __VERIFIER_atomic_begin 68
Line: 70
Line: 71
Line: 75
Line: 76
Line: 77
Line: 78
Line: 79
Line: 80
Line: 81
Line: 82
Line: 83
Line: 84
Line: 85
Line: 86
Line: 87
Line: 88
Line: 89
Line: 95
Line: 96
Line: 97
Line: 98
Line: 99
Line: 100
Line: 101
Line: 102
Line: 103
Line: 104
Line: 105
Line: 106
Line: 107
Line: 108
Line: 109
Line: 130
Line: 18
Line: 19
Line: 20
Property: start_routine == P0
Property: start_routine == P1
Line: 21
Line: 23
Line: 19
Line: 24
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: main
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constmain
main$tmp_guard0 = __unbuffered_cnt == 2;: 2
ASSUME: main$tmp_guard0 != FALSE
main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);: 3
ASSERT: !((signed long int)!(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0)) != 0l)
main#return_value = 0;: 0
Test dependency in main
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: fence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constfence
Test dependency in fence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: isync
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constisync
Test dependency in isync
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_end
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_end
ASSUME: __global_lock == 1
__global_lock = 0;: 1
Test dependency in __VERIFIER_atomic_end
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: __VERIFIER_atomic_begin
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) const__VERIFIER_atomic_begin
ASSUME: __global_lock == 0
__global_lock = 1;: 1
Test dependency in __VERIFIER_atomic_begin
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P0
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP0
y = 1;: 1
__unbuffered_p0_EAX = x;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P0#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P0
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : x 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: P1
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constP1
x = 1;: 1
__unbuffered_p1_EAX = y;: 2
__unbuffered_cnt = __unbuffered_cnt + 1;: 2
return_value_nondet_0$1 = NONDET(signed int);: 0
P1#return_value = (void *)return_value_nondet_0$1;: 0
Test dependency in P1
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_dependencies: lwfence
goto_programt::get_program_dependencies(std::vector<variable_struct> vars) constlwfence
Test dependency in lwfence
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : 
main$tmp_guard0: : 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
DONE goto_program
Test dependency in general
attr$object: pthread_create: 
arg$object: P0: 
arg$object: pthread_create: 
thread$object: pthread_create: 
arg$object: __actual_thread_spawn: 
arg: __actual_thread_spawn: 
id: __actual_thread_spawn: 
thread: pthread_create: 
arg: pthread_create: 
arg$object: P1: 
thread$object$object: pthread_create: 
_opaque_pthread_t: : 
__unbuffered_p0_EAX: : __unbuffered_p1_EAX x 
main$tmp_guard0: : __unbuffered_cnt 
arg: P0: 
_opaque_pthread_attr_t: : 
__unbuffered_p1_EAX: : __unbuffered_p0_EAX y 
__global_lock: : 
arg: P1: 
main$tmp_guard1: : __unbuffered_p0_EAX __unbuffered_p1_EAX 
y: : 
this_thread_id: pthread_create: 
attr: pthread_create: 
x: : 
__unbuffered_cnt: : 
Start DFS_dependence: 5
Slice variables: 
main$tmp_guard0
__unbuffered_cnt
__unbuffered_p0_EAX
__unbuffered_p1_EAX
x
__unbuffered_p1_EAX
y
__global_lock
__global_lock
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Slicing procedure: main
Slicing procedure: fence
Slicing procedure: isync
Do not slice _start
Do not slice __CPROVER_initialize
Do not slice pthread_create
Do not slice __VERIFIER_atomic_end
Do not slice __VERIFIER_atomic_begin
Slicing procedure: P0
Slicing procedure: P1
Slicing procedure: lwfence
Do not slice __actual_thread_spawn
0: -1
1: -1
2: -1
3: -1
4: -1
5: -1
6: -1
7: -1
8: -1
9: -1
10: -1
11: -1
12: -1
13: -1
14: -1
15: -1
16: -1
17: -1
18: -1
19: -1
20: -1
21: -1
22: -1
23: -1
24: -1
25: -1
26: -1
27: -1
28: -1
29: -1
30: -1
31: -1
32: -1
33: -1
34: -1
35: -1
36: -1
37: -1
38: -1
39: -1
40: -1
41: -1
42: -1
43: -1
44: -1
45: -1
46: -1
47: -1
48: -1
49: -1
50: -1
51: -1
52: -1
53: -1
54: -1
55: -1
56: -1
57: -1
58: -1
59: -1
60: -1
61: -1
62: -1
63: -1
64: -1
65: -1
66: -1
67: -1
68: -1
69: -1
70: -1
71: -1
72: -1
73: -1
74: -1
75: 6
76: 0
77: 6
78: 6
79: 6
80: 6
81: 0
82: 6
83: 6
84: 6
85: 6
86: 0
87: 6
88: 0
89: 0
90: -1
91: -1
92: -1
93: -1
94: -1
95: 6
96: 0
97: 6
98: 6
99: 6
100: 6
101: 0
102: 6
103: 6
104: 6
105: 6
106: 0
107: 6
108: 0
109: 0
110: -1
111: -1
112: -1
113: -1
114: -1
115: -1
116: 0
117: -1
118: -1
119: -1
120: -1
121: -1
122: -1
123: 0
124: -1
125: -1
126: -1
127: -1
128: -1
129: -1
130: 0
131: -1
132: -1
133: -1
134: -1
135: -1
136: 6
137: 6
138: 6
139: 0
140: 6
141: 0
142: 6
143: 6
144: 6
145: -1
146: -1
147: 2
148: 6
149: -1
150: -1
151: 0
152: 0
153: 0
154: -1
155: -1
156: -1
157: -1
158: -1
159: -1
160: -1
161: -1
162: -1


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{
  __VERIFIER_atomic_begin();
  y = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p0_EAX = x;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void * P1(void *arg)
{
  __VERIFIER_atomic_begin();
  x = 1;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_p1_EAX = y;
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  __unbuffered_cnt = __unbuffered_cnt + 1;
  __VERIFIER_atomic_end();
  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
  pthread_create(NULL, NULL, P0, NULL);
  pthread_create(NULL, NULL, P1, NULL);
  __VERIFIER_atomic_begin();
  main$tmp_guard0 = __unbuffered_cnt == 2;
  __VERIFIER_atomic_end();
  __VERIFIER_assume(main$tmp_guard0);
  __VERIFIER_atomic_begin();
  __VERIFIER_atomic_end();
  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  main$tmp_guard1 = !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0);
  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Removing from 77 to 78
Removing from 82 to 83
Removing from 97 to 98
Removing from 102 to 103
cut string: (NULL, NULL, P0, NULL)
after edit call command: pthread_create(NULL, NULL, P0, NULL);
cut string: (NULL, NULL, P1, NULL)
after edit call command: pthread_create(NULL, NULL, P1, NULL);
Removing from 141 to 142
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
counter: 0
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
counter: 0
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
counter: 0
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
counter: 0
at line 114:  
at line 115:}
counter: 0
at line 121:  
at line 122:}
counter: 0
at line 128:  
at line 129:}
counter: 0
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
counter: 0
at line 153:
at line 62:  __VERIFIER_assume(__global_lock==1); 
at line 63:  __global_lock=0; 
at line 64:  return; 
at line 65:}
at line 66:void __VERIFIER_atomic_begin() { 
at line 67:  __VERIFIER_assume(__global_lock==0); 
at line 68:  __global_lock=1; 
at line 69:  return; 
at line 70:}
at line 71:
at line 72:void * P0(void *arg)
at line 73:{
at line 74:  __VERIFIER_atomic_begin();
at line 75:  y = 1;
at line 76:  __VERIFIER_atomic_end();
at line 77:
at line 78:
at line 79:  __VERIFIER_atomic_begin();
at line 80:  __unbuffered_p0_EAX = x;
at line 81:  __VERIFIER_atomic_end();
at line 82:
at line 83:
at line 84:  __VERIFIER_atomic_begin();
at line 85:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 86:  __VERIFIER_atomic_end();
at line 87:  return nondet_0();
at line 88:}
at line 89:
at line 90:
at line 91:
at line 92:void * P1(void *arg)
at line 93:{
at line 94:  __VERIFIER_atomic_begin();
at line 95:  x = 1;
at line 96:  __VERIFIER_atomic_end();
at line 97:
at line 98:
at line 99:  __VERIFIER_atomic_begin();
at line 100:  __unbuffered_p1_EAX = y;
at line 101:  __VERIFIER_atomic_end();
at line 102:
at line 103:
at line 104:  __VERIFIER_atomic_begin();
at line 105:  __unbuffered_cnt = __unbuffered_cnt + 1;
at line 106:  __VERIFIER_atomic_end();
at line 107:  return nondet_0();
at line 108:}
at line 109:
at line 110:
at line 111:
at line 112:void fence()
at line 113:{
at line 114:  
at line 115:}
at line 116:
at line 117:
at line 118:
at line 119:void isync()
at line 120:{
at line 121:  
at line 122:}
at line 123:
at line 124:
at line 125:
at line 126:void lwfence()
at line 127:{
at line 128:  
at line 129:}
at line 130:
at line 131:
at line 132:
at line 133:int main()
at line 134:{
at line 135:pthread_create(NULL, NULL, P0, NULL);
at line 136:pthread_create(NULL, NULL, P1, NULL);
at line 137:  __VERIFIER_atomic_begin();
at line 138:  main$tmp_guard0 = __unbuffered_cnt == 2;
at line 139:  __VERIFIER_atomic_end();
at line 140:  __VERIFIER_assume(main$tmp_guard0);
at line 141:
at line 142:
at line 143:  __VERIFIER_atomic_begin();
at line 144:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 145:This likely is a bug in the tool chain. */
at line 146:
at line 147:  __VERIFIER_atomic_end();
at line 148:  /* Program was expected to be safe for X86, model checker should have said NO.
at line 149:This likely is a bug in the tool chain. */
at line 150:  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
at line 151:  return 0;
at line 152:}
at line 153:


#include <assert.h>
#include <pthread.h>
#ifndef TRUE
#define TRUE (_Bool)1
#endif
#ifndef FALSE
#define FALSE (_Bool)0
#endif
#ifndef NULL
#define NULL ((void*)0)
#endif
#ifndef FENCE
#define FENCE(x) ((void)0)
#endif
#ifndef IEEE_FLOAT_EQUAL
#define IEEE_FLOAT_EQUAL(x,y) (x==y)
#endif
#ifndef IEEE_FLOAT_NOTEQUAL
#define IEEE_FLOAT_NOTEQUAL(x,y) (x!=y)
#endif



int __unbuffered_cnt;


int __unbuffered_cnt = 0;


int __unbuffered_p0_EAX;


int __unbuffered_p0_EAX = 0;


int __unbuffered_p1_EAX;


int __unbuffered_p1_EAX = 0;


_Bool main$tmp_guard0;


_Bool main$tmp_guard1;


int x;


int x = 0;


int y;


int y = 0;

int __global_lock;
void __VERIFIER_atomic_end() { 
  __VERIFIER_assume(__global_lock==1); 
  __global_lock=0; 
  return; 
}
void __VERIFIER_atomic_begin() { 
  __VERIFIER_assume(__global_lock==0); 
  __global_lock=1; 
  return; 
}

void * P0(void *arg)
{

  y = 1;




  __unbuffered_p0_EAX = x;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void * P1(void *arg)
{

  x = 1;




  __unbuffered_p1_EAX = y;




  __unbuffered_cnt = __unbuffered_cnt + 1;

  return nondet_0();
}



void fence()
{
  
}



void isync()
{
  
}



void lwfence()
{
  
}



int main()
{
pthread_create(NULL, NULL, P0, NULL);
pthread_create(NULL, NULL, P1, NULL);

  main$tmp_guard0 = __unbuffered_cnt == 2;

  __VERIFIER_assume(main$tmp_guard0);


  __VERIFIER_atomic_begin();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */

  __VERIFIER_atomic_end();
  /* Program was expected to be safe for X86, model checker should have said NO.
This likely is a bug in the tool chain. */
  assert(!(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0));
  return 0;
}

Update CFG: 115 116
Update CFG: 122 123
Update CFG: 129 130
0: 130 95 75 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 76 
76: 77 
77: 78 
78: 79 
79: 80 
80: 81 
81: 82 
82: 83 
83: 84 
84: 85 
85: 86 
86: 87 
87: 88 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 96 
96: 97 
97: 98 
98: 99 
99: 100 
100: 101 
101: 102 
102: 103 
103: 104 
104: 105 
105: 106 
106: 107 
107: 108 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 116 
116: 
117: 
118: 
119: 
120: 
121: 
122: 123 
123: 
124: 
125: 
126: 
127: 
128: 
129: 130 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 138 
138: 139 
139: 140 
140: 141 
141: 142 
142: 143 
143: 144 
144: 147 
145: 
146: 
147: 148 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
CBMC version 5.1 64-bit x86_64 macos
Parsing //Users//diepbp//Desktop//test//slicing_init.c
Converting
Type-checking slicing_init
Generating GOTO Program
keng keng keng
Adding CPROVER library
Function Pointer Removal
Partial Inlining
Generic Property Instrumentation
we going to get_CFG()Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
Total line: 153
std::vector<std::vector<int>> goto_functions_templatet<bodyT>::get_CFG()
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
GOTO is nill
0: 130 96 76 68 63 123 116 136 
1: 
2: 
3: 
4: 
5: 
6: 
7: 
8: 
9: 
10: 
11: 
12: 
13: 
14: 
15: 
16: 
17: 
18: 
19: 
20: 
21: 
22: 
23: 
24: 
25: 
26: 
27: 
28: 
29: 
30: 
31: 
32: 
33: 
34: 
35: 
36: 
37: 
38: 
39: 
40: 
41: 
42: 
43: 
44: 
45: 
46: 
47: 
48: 
49: 
50: 
51: 
52: 
53: 
54: 
55: 
56: 
57: 
58: 
59: 
60: 
61: 
62: 
63: 64 
64: 65 
65: 66 
66: 
67: 
68: 69 
69: 70 
70: 71 
71: 
72: 
73: 
74: 
75: 
76: 81 
77: 
78: 
79: 
80: 
81: 86 
82: 
83: 
84: 
85: 
86: 88 
87: 
88: 89 
89: 
90: 
91: 
92: 
93: 
94: 
95: 
96: 101 
97: 
98: 
99: 
100: 
101: 106 
102: 
103: 
104: 
105: 
106: 108 
107: 
108: 109 
109: 
110: 
111: 
112: 
113: 
114: 
115: 
116: 
117: 
118: 
119: 
120: 
121: 
122: 
123: 
124: 
125: 
126: 
127: 
128: 
129: 
130: 
131: 
132: 
133: 
134: 
135: 
136: 137 
137: 139 
138: 
139: 141 
140: 
141: 144 
142: 
143: 
144: 148 
145: 
146: 
147: 
148: 151 
149: 
150: 
151: 152 
152: 153 
153: 
154: 
155: 
156: 
157: 
158: 
159: 
160: 
161: 
162: 
Starting Bounded Model Checking
Adding SC constraints
size of program expression: 353 steps
no slicing due to threads
Generated 1 VCC(s), 1 remaining after simplification
what is here 1 1
before testing
in bool bmct::all_properties
Passing problem to propositional reduction
converting SSA
Number of assertions: 1
goal: main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 
Running propositional reduction
Post-processing ting ting ting
Solving with MiniSAT 2.2.0 with simplifier
2877 variables, 9638 clauses
SAT checker: negated claim is UNSATISFIABLE, i.e., holds
Runtime decision procedure: 0.102s

** Results:
[main.assertion.1] assertion !(__unbuffered_p0_EAX == 0 && __unbuffered_p1_EAX == 0): OK
goal-- main$tmp_guard0#3 != FALSE && __global_lock#3 == 0 && __global_lock#6 == 1 ==> !(__unbuffered_p0_EAX#2 == 0) || !(__unbuffered_p1_EAX#2 == 0) -- 

** 0 of 1 failed (1 iterations)
Number of loop traces: 1
